{"version":3,"sources":["sm3.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * JavaScript SM3\n * https://github.com/jiaxingzheng/JavaScript-SM3\n *\n * Copyright 2017, Zheng Jiaxing\n *\n * Licensed under the MIT license:\n * http://www.opensource.org/licenses/MIT\n *\n * Refer to\n * http://www.oscca.gov.cn/UpFile/20101222141857786.pdf\n */\n\n\n// 左补0到指定长度\nfunction leftPad(str, totalLength) {\n  const len = str.length;\n  return Array(totalLength > len ? ((totalLength - len) + 1) : 0).join(0) + str;\n}\n\n// 二进制转化为十六进制\nfunction binary2hex(binary) {\n  const binaryLength = 8;\n  let hex = '';\n  for (let i = 0; i < binary.length / binaryLength; i += 1) {\n    hex += leftPad(parseInt(binary.substr(i * binaryLength, binaryLength), 2).toString(16), 2);\n  }\n  return hex;\n}\n\n// 十六进制转化为二进制\nfunction hex2binary(hex) {\n  const hexLength = 2;\n  let binary = '';\n  for (let i = 0; i < hex.length / hexLength; i += 1) {\n    binary += leftPad(parseInt(hex.substr(i * hexLength, hexLength), 16).toString(2), 8);\n  }\n  return binary;\n}\n\n// utf16码点值转化为utf8二进制\nfunction utf16CodePoint2utf8Binary(ch) {\n  const utf8Arr = [];\n  const codePoint = ch.codePointAt(0);\n\n  if (codePoint >= 0x00 && codePoint <= 0x7f) {\n    utf8Arr.push(codePoint);\n  } else if (codePoint >= 0x80 && codePoint <= 0x7ff) {\n    utf8Arr.push((192 | (31 & (codePoint >> 6))));\n    utf8Arr.push((128 | (63 & codePoint)))\n  } else if ((codePoint >= 0x800 && codePoint <= 0xd7ff)\n    || (codePoint >= 0xe000 && codePoint <= 0xffff)) {\n    utf8Arr.push((224 | (15 & (codePoint >> 12))));\n    utf8Arr.push((128 | (63 & (codePoint >> 6))));\n    utf8Arr.push((128 | (63 & codePoint)))\n  } else if (codePoint >= 0x10000 && codePoint <= 0x10ffff) {\n    utf8Arr.push((240 | (7 & (codePoint >> 18))));\n    utf8Arr.push((128 | (63 & (codePoint >> 12))));\n    utf8Arr.push((128 | (63 & (codePoint >> 6))));\n    utf8Arr.push((128 | (63 & codePoint)))\n  }\n\n  let binary = '';\n  for (let utf8Code of utf8Arr) {\n    const b = utf8Code.toString(2);\n    binary += leftPad(b, Math.ceil(b.length / 8) * 8);\n  }\n\n  return binary;\n}\n\n// 普通字符串转化为二进制\nfunction str2binary(str) {\n  let binary = '';\n  for (const ch of str) {\n    binary += utf16CodePoint2utf8Binary(ch);\n  }\n  return binary;\n}\n\n// 循环左移\nfunction rol(str, n) {\n  return str.substring(n % str.length) + str.substr(0, n % str.length);\n}\n\n// 二进制运算\nfunction binaryCal(x, y, method) {\n  const a = x || '';\n  const b = y || '';\n  const result = [];\n  let prevResult;\n  // for (let i = 0; i < a.length; i += 1) { // 小端\n  for (let i = a.length - 1; i >= 0; i -= 1) { // 大端\n    prevResult = method(a[i], b[i], prevResult);\n    result[i] = prevResult[0];\n  }\n  // console.log(`x     :${x}\\ny     :${y}\\nresult:${result.join('')}\\n`);\n  return result.join('');\n}\n\n// 二进制异或运算\nfunction xor(x, y) {\n  return binaryCal(x, y, (a, b) => [(a === b ? '0' : '1')]);\n}\n\n// 二进制与运算\nfunction and(x, y) {\n  return binaryCal(x, y, (a, b) => [(a === '1' && b === '1' ? '1' : '0')]);\n}\n\n// 二进制或运算\nfunction or(x, y) {\n  return binaryCal(x, y, (a, b) => [(a === '1' || b === '1' ? '1' : '0')]);// a === '0' && b === '0' ? '0' : '1'\n}\n\n// 二进制与运算\nfunction add(x, y) {\n  const result = binaryCal(x, y, (a, b, prevResult) => {\n    const carry = prevResult ? prevResult[1] : '0' || '0';\n    if (a !== b) return [carry === '0' ? '1' : '0', carry];// a,b不等时,carry不变，结果与carry相反\n    // a,b相等时，结果等于原carry，新carry等于a\n    return [carry, a];\n  });\n  // console.log('x: ' + x + '\\ny: ' + y + '\\n=  ' + result + '\\n');\n  return result;\n}\n\n// 二进制非运算\nfunction not(x) {\n  return binaryCal(x, undefined, a => [a === '1' ? '0' : '1']);\n}\n\nfunction calMulti(method) {\n  return (...arr) => arr.reduce((prev, curr) => method(prev, curr));\n}\n\n// function xorMulti(...arr) {\n//   return arr.reduce((prev, curr) => xor(prev, curr));\n// }\n\n// 压缩函数中的置换函数 P1(X) = X xor (X <<< 9) xor (X <<< 17)\nfunction P0(X) {\n  return calMulti(xor)(X, rol(X, 9), rol(X, 17));\n}\n\n// 消息扩展中的置换函数 P1(X) = X xor (X <<< 15) xor (X <<< 23)\nfunction P1(X) {\n  return calMulti(xor)(X, rol(X, 15), rol(X, 23));\n}\n\n// 布尔函数，随j的变化取不同的表达式\nfunction FF(X, Y, Z, j) {\n  return j >= 0 && j <= 15 ? calMulti(xor)(X, Y, Z) : calMulti(or)(and(X, Y), and(X, Z), and(Y, Z));\n}\n\n// 布尔函数，随j的变化取不同的表达式\nfunction GG(X, Y, Z, j) {\n  return j >= 0 && j <= 15 ? calMulti(xor)(X, Y, Z) : or(and(X, Y), and(not(X), Z));\n}\n\n// 常量，随j的变化取不同的值\nfunction T(j) {\n  return j >= 0 && j <= 15 ? hex2binary('79cc4519') : hex2binary('7a879d8a');\n}\n\n// 压缩函数\nfunction CF(V, Bi) {\n  // 消息扩展\n  const wordLength = 32;\n  const W = [];\n  const M = [];// W'\n\n  // 将消息分组B划分为16个字W0， W1，…… ，W15 （字为长度为32的比特串）\n  for (let i = 0; i < 16; i += 1) {\n    W.push(Bi.substr(i * wordLength, wordLength));\n  }\n\n  // W[j] <- P1(W[j−16] xor W[j−9] xor (W[j−3] <<< 15)) xor (W[j−13] <<< 7) xor W[j−6]\n  for (let j = 16; j < 68; j += 1) {\n    W.push(calMulti(xor)(\n      P1(calMulti(xor)(W[j - 16], W[j - 9], rol(W[j - 3], 15))),\n      rol(W[j - 13], 7),\n      W[j - 6]\n    ));\n  }\n\n  // W′[j] = W[j] xor W[j+4]\n  for (let j = 0; j < 64; j += 1) {\n    M.push(xor(W[j], W[j + 4]));\n  }\n\n  // 压缩\n  const wordRegister = [];// 字寄存器\n  for (let j = 0; j < 8; j += 1) {\n    wordRegister.push(V.substr(j * wordLength, wordLength));\n  }\n\n  let A = wordRegister[0];\n  let B = wordRegister[1];\n  let C = wordRegister[2];\n  let D = wordRegister[3];\n  let E = wordRegister[4];\n  let F = wordRegister[5];\n  let G = wordRegister[6];\n  let H = wordRegister[7];\n\n  // 中间变量\n  let SS1;\n  let SS2;\n  let TT1;\n  let TT2;\n  for (let j = 0; j < 64; j += 1) {\n    SS1 = rol(calMulti(add)(rol(A, 12), E, rol(T(j), j)), 7);\n    SS2 = xor(SS1, rol(A, 12));\n\n    TT1 = calMulti(add)(FF(A, B, C, j), D, SS2, M[j]);\n    TT2 = calMulti(add)(GG(E, F, G, j), H, SS1, W[j]);\n\n    D = C;\n    C = rol(B, 9);\n    B = A;\n    A = TT1;\n    H = G;\n    G = rol(F, 19);\n    F = E;\n    E = P0(TT2);\n  }\n\n  return xor(Array(A, B, C, D, E, F, G, H).join(''), V);\n}\n\n// sm3 hash算法 http://www.oscca.gov.cn/News/201012/News_1199.htm\nfunction sm3(str) {\n  const binary = str2binary(str);\n  // 填充\n  const len = binary.length;\n  // k是满足len + 1 + k = 448mod512的最小的非负整数\n  let k = len % 512;\n  // 如果 448 <= (512 % len) < 512，需要多补充 (len % 448) 比特'0'以满足总比特长度为512的倍数\n  k = k >= 448 ? 512 - (k % 448) - 1: 448 - k - 1;\n  const m = `${binary}1${leftPad('', k)}${leftPad(len.toString(2), 64)}`.toString();// k个0\n\n  // 迭代压缩\n  const n = (len + k + 65) / 512;\n\n  let V = hex2binary('7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e');\n  for (let i = 0; i <= n - 1; i += 1) {\n    const B = m.substr(512 * i, 512);\n    V = CF(V, B);\n  }\n  return binary2hex(V);\n}\n\nmodule.exports = sm3;\n"]}