{"version":3,"sources":["container.js","connection.js","errors.js","util.js","frames.js","types.js","log.js","sasl.js","transport.js","endpoint.js","session.js","link.js","message.js","terminus.js","eventTypes.js","ws.js","filter.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ACHA,AFMA;AFOA,ADGA,AENA,AENA,ACHA,AFMA;AFOA,ADGA,AENA,AENA,ACHA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ADGA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ADGA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ADGA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ACHA,AFMA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ACHA,AFMA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ACHA,AFMA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ACHA,ACHA,AHSA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ACHA,ACHA,AHSA,AFMA;AFOA,ADGA,AENA,AENA,AENA,ACHA,ACHA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AENA,ACHA,ACHA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AENA,ACHA,ACHA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AENA,ACHA,ACHA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AENA,ACHA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AENA,ACHA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AENA,ACHA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,ACHA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,ACHA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,ACHA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AFMA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AENA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AYpCA,AV8BA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AYpCA,AV8BA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AYpCA,AV8BA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA;AFOA,ADGA,AS3BA,APqBA,AYpCA,AV8BA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AV8BA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AV8BA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ALeA,AMlBA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,APqBA,AYpCA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AENA,AZoCA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AFMA,AYpCA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,ADGA,AS3BA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AGTA,ALeA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA,AU9BA;Ad2CA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AQxBA,AKfA,AV8BA,AOrBA,ACHA,ALeA,AGTA,AFMA,AHSA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AavCA,AV8BA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,ACHA,ALeA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AGTA,AOrBA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AU9BA,AJYA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AMlBA,AGTA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AS3BA,ALeA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar Connection = require('./connection.js');\nvar log = require('./log.js');\nvar sasl = require('./sasl.js');\nvar util = require('./util.js');\nvar eventTypes = require('./eventTypes.js');\n\nvar net = require('net');\nvar tls = require('tls');\nvar EventEmitter = require('events').EventEmitter;\n\nvar Container = function (options) {\n    this.options = options ? Object.create(options) : {};\n    if (!this.options.id) {\n        this.options.id = util.generate_uuid();\n    }\n    this.id = this.options.id;\n    this.sasl_server_mechanisms = sasl.server_mechanisms();\n};\n\nContainer.prototype = Object.create(EventEmitter.prototype);\nContainer.prototype.constructor = Container;\nContainer.prototype.dispatch = function(name) {\n    log.events('[%s] Container got event: ' + name, this.id);\n    EventEmitter.prototype.emit.apply(this, arguments);\n    if (this.listeners(name).length) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nContainer.prototype.connect = function (options) {\n    return new Connection(options, this).connect();\n};\n\nContainer.prototype.create_connection = function (options) {\n    return new Connection(options, this);\n};\n\nContainer.prototype.listen = function (options) {\n    var container = this;\n    var server;\n    if (options.transport === undefined || options.transport === 'tcp') {\n        server = net.createServer(options);\n        server.on('connection', function (socket) {\n            new Connection(options, container).accept(socket);\n        });\n    } else if (options.transport === 'tls' || options.transport === 'ssl') {\n        server = tls.createServer(options);\n        server.on('secureConnection', function (socket) {\n            new Connection(options, container).accept(socket);\n        });\n    } else {\n        throw Error('Unrecognised transport: ' + options.transport);\n    }\n    if (process.version.match(/v0\\.10\\.\\d+/)) {\n        server.listen(options.port, options.host);\n    } else {\n        server.listen(options);\n    }\n    return server;\n};\n\nContainer.prototype.create_container = function (options) {\n    return new Container(options);\n};\n\nContainer.prototype.get_option = function (name, default_value) {\n    if (this.options[name] !== undefined) return this.options[name];\n    else return default_value;\n};\n\nContainer.prototype.generate_uuid = util.generate_uuid;\nContainer.prototype.string_to_uuid = util.string_to_uuid;\nContainer.prototype.uuid_to_string = util.uuid_to_string;\nvar ws = require('./ws.js');\nContainer.prototype.websocket_accept = function(socket, options) {\n    new Connection(options, this).accept(ws.wrap(socket));\n};\nContainer.prototype.websocket_connect = ws.connect;\nContainer.prototype.filter = require('./filter.js');\nContainer.prototype.types = require('./types.js');\nContainer.prototype.message = require('./message.js');\nContainer.prototype.sasl = sasl;\nContainer.prototype.ReceiverEvents = eventTypes.ReceiverEvents;\nContainer.prototype.SenderEvents = eventTypes.SenderEvents;\nContainer.prototype.SessionEvents = eventTypes.SessionEvents;\nContainer.prototype.ConnectionEvents = eventTypes.ConnectionEvents;\n\nmodule.exports = new Container();\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar errors = require('./errors.js');\nvar frames = require('./frames.js');\nvar log = require('./log.js');\nvar sasl = require('./sasl.js');\nvar util = require('./util.js');\nvar EndpointState = require('./endpoint.js');\nvar Session = require('./session.js');\nvar Transport = require('./transport.js');\n\nvar fs = require('fs');\nvar os = require('os');\nvar path = require('path');\nvar net = require('net');\nvar tls = require('tls');\nvar EventEmitter = require('events').EventEmitter;\n\nvar AMQP_PROTOCOL_ID = 0x00;\n\nfunction find_connect_config() {\n    var paths;\n    if (process.env.MESSAGING_CONNECT_FILE) {\n        paths = [process.env.MESSAGING_CONNECT_FILE];\n    } else {\n        paths = [process.cwd(), path.join(os.homedir(), '.config/messaging'),'/etc/messaging'].map(function (base) { return path.join(base, '/connect.json'); });\n    }\n    for (var i = 0; i < paths.length; i++) {\n        if (fs.existsSync(paths[i])) {\n            var obj = JSON.parse(fs.readFileSync(paths[i], 'utf8'));\n            log.config('using config from %s: %j', paths[i], obj);\n            return obj;\n        }\n    }\n    return {};\n}\n\nfunction get_default_connect_config() {\n    var config = find_connect_config();\n    var options = {};\n    if (config.scheme === 'amqps') options.transport = 'tls';\n    if (config.host) options.host = config.host;\n    if(config.port === 'amqp') options.port = 5672;\n    else if(config.port === 'amqps') options.port = 5671;\n    else options.port = config.port;\n    if (!(config.sasl && config.sasl.enabled === false)) {\n        if (config.user) options.username = config.user;\n        else options.username = 'anonymous';\n        if (config.password) options.password = config.password;\n        if (config.sasl_mechanisms) options.sasl_mechanisms = config.sasl_mechanisms;\n    }\n    if (config.tls) {\n        if (config.tls.key) options.key = fs.readFileSync(config.tls.key);\n        if (config.tls.cert) options.cert = fs.readFileSync(config.tls.cert);\n        if (config.tls.ca) options.ca = [ fs.readFileSync(config.tls.ca) ];\n        if (config.verify === false || config.tls.verify === false) options.rejectUnauthorized = false;\n    }\n    if (options.transport === 'tls') {\n        options.servername = options.host;\n    }\n    return options;\n}\n\nfunction get_socket_id(socket) {\n    if (socket.get_id_string) return socket.get_id_string();\n    return socket.localAddress + ':' + socket.localPort + ' -> ' + socket.remoteAddress + ':' + socket.remotePort;\n}\n\nfunction session_per_connection(conn) {\n    var ssn = null;\n    return {\n        'get_session' : function () {\n            if (!ssn) {\n                ssn = conn.create_session();\n                ssn.observers.on('session_close', function () { ssn = null; });\n                ssn.begin();\n            }\n            return ssn;\n        }\n    };\n}\n\nfunction restrict(count, f) {\n    if (count) {\n        var current = count;\n        var reset;\n        return function (successful_attempts) {\n            if (reset !== successful_attempts) {\n                current = count;\n                reset = successful_attempts;\n            }\n            if (current--) return f(successful_attempts);\n            else return -1;\n        };\n    } else {\n        return f;\n    }\n}\n\nfunction backoff(initial, max) {\n    var delay = initial;\n    var reset;\n    return function (successful_attempts) {\n        if (reset !== successful_attempts) {\n            delay = initial;\n            reset = successful_attempts;\n        }\n        var current = delay;\n        var next = delay*2;\n        delay = max > next ? next : max;\n        return current;\n    };\n}\n\nfunction get_connect_fn(options) {\n    if (options.transport === undefined || options.transport === 'tcp') {\n        return net.connect;\n    } else if (options.transport === 'tls' || options.transport === 'ssl') {\n        return tls.connect;\n    } else {\n        throw Error('Unrecognised transport: ' + options.transport);\n    }\n}\n\nfunction connection_details(options) {\n    var details = {};\n    details.connect = options.connect ? options.connect : get_connect_fn(options);\n    details.host = options.host ? options.host : 'localhost';\n    details.port = options.port ? options.port : 5672;\n    details.options = options;\n    return details;\n}\n\nvar aliases = [\n    'container_id',\n    'hostname',\n    'max_frame_size',\n    'channel_max',\n    'idle_time_out',\n    'outgoing_locales',\n    'incoming_locales',\n    'offered_capabilities',\n    'desired_capabilities',\n    'properties'\n];\n\nfunction remote_property_shortcut(name) {\n    return function() { return this.remote.open ? this.remote.open[name] : undefined; };\n}\n\nfunction connection_fields(fields) {\n    var o = {};\n    aliases.forEach(function (name) {\n        if (fields[name] !== undefined) {\n            o[name] = fields[name];\n        }\n    });\n    return o;\n}\n\nfunction set_reconnect(reconnect, connection) {\n    if (typeof reconnect === 'boolean') {\n        if (reconnect) {\n            var initial = connection.get_option('initial_reconnect_delay', 100);\n            var max = connection.get_option('max_reconnect_delay', 60000);\n            connection.options.reconnect = restrict(\n                connection.get_option('reconnect_limit'),\n                backoff(initial, max)\n            );\n        } else {\n            connection.options.reconnect = false;\n        }\n    } else if (typeof reconnect === 'number') {\n        var fixed = connection.options.reconnect;\n        connection.options.reconnect = restrict(\n            connection.get_option('reconnect_limit'),\n            function() {\n                return fixed;\n            }\n        );\n    }\n}\n\nvar conn_counter = 1;\n\nvar Connection = function (options, container) {\n    this.options = {};\n    if (options) {\n        for (var k in options) {\n            this.options[k] = options[k];\n        }\n        if ((options.transport === 'tls' || options.transport === 'ssl')\n            && options.servername === undefined && options.host !== undefined) {\n            this.options.servername = options.host;\n        }\n    } else {\n        this.options = get_default_connect_config();\n    }\n    this.container = container;\n    if (!this.options.id) {\n        this.options.id = 'connection-' + conn_counter++;\n    }\n    if (!this.options.container_id) {\n        this.options.container_id = container ? container.id : util.generate_uuid();\n    }\n    if (!this.options.connection_details) {\n        var self = this;\n        this.options.connection_details = function() { return connection_details(self.options); };\n    }\n    var reconnect = this.get_option('reconnect', true);\n    set_reconnect(reconnect, this);\n    this.registered = false;\n    this.state = new EndpointState();\n    this.local_channel_map = {};\n    this.remote_channel_map = {};\n    this.local = {};\n    this.remote = {};\n    this.local.open = frames.open(connection_fields(this.options));\n    this.local.close = frames.close({});\n    this.session_policy = session_per_connection(this);\n    this.amqp_transport = new Transport(this.options.id, AMQP_PROTOCOL_ID, frames.TYPE_AMQP, this);\n    this.sasl_transport = undefined;\n    this.transport = this.amqp_transport;\n    this.conn_established_counter = 0;\n    this.heartbeat_out = undefined;\n    this.heartbeat_in = undefined;\n    this.abort_idle = undefined;\n    this.socket_ready = false;\n    this.scheduled_reconnect = undefined;\n    this.default_sender = undefined;\n    this.closed_with_non_fatal_error = false;\n\n    var self = this;\n    aliases.forEach(function (alias) { Object.defineProperty(self, alias, { get: remote_property_shortcut(alias) }); });\n    Object.defineProperty(this, 'error', { get:  function() { return this.remote.close ? this.remote.close.error : undefined; }});\n};\n\nConnection.prototype = Object.create(EventEmitter.prototype);\nConnection.prototype.constructor = Connection;\nConnection.prototype.dispatch = function(name) {\n    log.events('[%s] Connection got event: %s', this.options.id, name);\n    if (this.listeners(name).length) {\n        EventEmitter.prototype.emit.apply(this, arguments);\n        return true;\n    } else if (this.container) {\n        return this.container.dispatch.apply(this.container, arguments);\n    } else {\n        return false;\n    }\n};\n\nConnection.prototype._disconnect = function() {\n    this.state.disconnected();\n    for (var k in this.local_channel_map) {\n        this.local_channel_map[k]._disconnect();\n    }\n    this.socket_ready = false;\n};\n\nConnection.prototype._reconnect = function() {\n    if (this.abort_idle) {\n        clearTimeout(this.abort_idle);\n        this.abort_idle = undefined;\n        this.local.close.error = undefined;\n        this.state = new EndpointState();\n        this.state.open();\n    }\n\n    this.state.reconnect();\n    this._reset_remote_state();\n};\n\nConnection.prototype._reset_remote_state = function() {\n    //reset transport\n    this.amqp_transport = new Transport(this.options.id, AMQP_PROTOCOL_ID, frames.TYPE_AMQP, this);\n    this.sasl_transport = undefined;\n    this.transport = this.amqp_transport;\n\n    //reset remote endpoint state\n    this.remote = {};\n    //reset sessions:\n    this.remote_channel_map = {};\n    var localChannelMap = this.local_channel_map;\n    for (var k in localChannelMap) {\n        localChannelMap[k]._reconnect();\n    }\n};\n\nConnection.prototype.connect = function () {\n    this.is_server = false;\n    if (this.abort_idle) {\n        clearTimeout(this.abort_idle);\n        this.abort_idle = undefined;\n    }\n    this._reset_remote_state();\n    this._connect(this.options.connection_details(this.conn_established_counter));\n    this.open();\n    return this;\n};\n\nConnection.prototype.reconnect = function () {\n    this.scheduled_reconnect = undefined;\n    log.reconnect('[%s] reconnecting...', this.options.id);\n    this._reconnect();\n    this._connect(this.options.connection_details(this.conn_established_counter));\n    process.nextTick(this._process.bind(this));\n    return this;\n};\n\nConnection.prototype.set_reconnect = function (reconnect) {\n    set_reconnect(reconnect, this);\n};\n\nConnection.prototype._connect = function (details) {\n    if (details.connect) {\n        this.init(details.connect(details.port, details.host, details.options, this.connected.bind(this)));\n    } else {\n        this.init(get_connect_fn(details)(details.port, details.host, details.options, this.connected.bind(this)));\n    }\n    return this;\n};\n\nConnection.prototype.accept = function (socket) {\n    this.is_server = true;\n    log.io('[%s] client accepted: %s', this.id, get_socket_id(socket));\n    this.socket_ready = true;\n    return this.init(socket);\n};\n\n\nConnection.prototype.abort_socket = function (socket) {\n    if (socket === this.socket) {\n        this.abort_idle = undefined;\n        log.io('[%s] aborting socket', this.options.id);\n        this.socket.end();\n        if (this.socket.removeAllListeners) {\n            this.socket.removeAllListeners('data');\n            this.socket.removeAllListeners('error');\n            this.socket.removeAllListeners('end');\n        }\n        if (typeof this.socket.destroy === 'function') {\n            this.socket.destroy();\n        }\n        this._disconnected();\n    }\n};\n\nConnection.prototype.init = function (socket) {\n    this.socket = socket;\n    if (this.get_option('tcp_no_delay', false) && this.socket.setNoDelay) {\n        this.socket.setNoDelay(true);\n    }\n    this.socket.on('data', this.input.bind(this));\n    this.socket.on('error', this.on_error.bind(this));\n    this.socket.on('end', this.eof.bind(this));\n\n    if (this.is_server) {\n        var mechs;\n        if (this.container && Object.getOwnPropertyNames(this.container.sasl_server_mechanisms).length) {\n            mechs = this.container.sasl_server_mechanisms;\n        }\n        if (this.socket.encrypted && this.socket.authorized && this.get_option('enable_sasl_external', false)) {\n            mechs = sasl.server_add_external(mechs ? util.clone(mechs) : {});\n        }\n        if (mechs) {\n            if (mechs.ANONYMOUS !== undefined && !this.get_option('require_sasl', false)) {\n                this.sasl_transport = new sasl.Selective(this, mechs);\n            } else {\n                this.sasl_transport = new sasl.Server(this, mechs);\n            }\n        } else {\n            if (!this.get_option('disable_sasl', false)) {\n                var anon = sasl.server_mechanisms();\n                anon.enable_anonymous();\n                this.sasl_transport = new sasl.Selective(this, anon);\n            }\n        }\n    } else {\n        var mechanisms = this.get_option('sasl_mechanisms');\n        if (!mechanisms) {\n            var username = this.get_option('username');\n            var password = this.get_option('password');\n            var token = this.get_option('token');\n            if (username) {\n                mechanisms = sasl.client_mechanisms();\n                if (password) mechanisms.enable_plain(username, password);\n                else if (token) mechanisms.enable_xoauth2(username, token);\n                else mechanisms.enable_anonymous(username);\n            }\n        }\n        if (this.socket.encrypted && this.options.cert && this.get_option('enable_sasl_external', false)) {\n            if (!mechanisms) mechanisms = sasl.client_mechanisms();\n            mechanisms.enable_external();\n        }\n\n        if (mechanisms) {\n            this.sasl_transport = new sasl.Client(this, mechanisms, this.options.sasl_init_hostname || this.options.servername || this.options.host);\n        }\n    }\n    this.transport = this.sasl_transport ? this.sasl_transport : this.amqp_transport;\n    return this;\n};\n\nConnection.prototype.attach_sender = function (options) {\n    return this.session_policy.get_session().attach_sender(options);\n};\nConnection.prototype.open_sender = Connection.prototype.attach_sender;//alias\n\nConnection.prototype.attach_receiver = function (options) {\n    if (this.get_option('tcp_no_delay', true) && this.socket.setNoDelay) {\n        this.socket.setNoDelay(true);\n    }\n    return this.session_policy.get_session().attach_receiver(options);\n};\nConnection.prototype.open_receiver = Connection.prototype.attach_receiver;//alias\n\nConnection.prototype.get_option = function (name, default_value) {\n    if (this.options[name] !== undefined) return this.options[name];\n    else if (this.container) return this.container.get_option(name, default_value);\n    else return default_value;\n};\n\nConnection.prototype.send = function(msg) {\n    if (this.default_sender === undefined) {\n        this.default_sender = this.open_sender({target:{}});\n    }\n    return this.default_sender.send(msg);\n};\n\nConnection.prototype.connected = function () {\n    this.socket_ready = true;\n    this.conn_established_counter++;\n    log.io('[%s] connected %s', this.options.id, get_socket_id(this.socket));\n    this.output();\n};\n\nConnection.prototype.sasl_failed = function (text, condition) {\n    this.transport_error = new errors.ConnectionError(text, condition ? condition : 'amqp:unauthorized-access', this);\n    this._handle_error();\n    this.socket.end();\n};\n\nConnection.prototype._is_fatal = function (error_condition) {\n    var all_errors_non_fatal = this.get_option('all_errors_non_fatal', false);\n    if (all_errors_non_fatal) {\n        return false;\n    } else {\n        var non_fatal = this.get_option('non_fatal_errors', ['amqp:connection:forced']);\n        return non_fatal.indexOf(error_condition) < 0;\n    }\n};\n\nConnection.prototype._handle_error = function () {\n    var error = this.get_error();\n    if (error) {\n        var handled = this.dispatch('connection_error', this._context({error:error}));\n        handled = this.dispatch('connection_close', this._context({error:error})) || handled;\n\n        if (!this._is_fatal(error.condition)) {\n            if (this.state.local_open) {\n                this.closed_with_non_fatal_error = true;\n            }\n        } else if (!handled) {\n            this.dispatch('error', new errors.ConnectionError(error.description, error.condition, this));\n        }\n        return true;\n    } else {\n        return false;\n    }\n};\n\nConnection.prototype.get_error = function () {\n    if (this.transport_error) return this.transport_error;\n    if (this.remote.close && this.remote.close.error) {\n        return new errors.ConnectionError(this.remote.close.error.description, this.remote.close.error.condition, this);\n    }\n    return undefined;\n};\n\nConnection.prototype._get_peer_details = function () {\n    var s = '';\n    if (this.remote.open && this.remote.open.container) {\n        s += this.remote.open.container + ' ';\n    }\n    if (this.remote.open && this.remote.open.properties) {\n        s += JSON.stringify(this.remote.open.properties);\n    }\n    return s;\n};\n\nConnection.prototype.output = function () {\n    try {\n        if (this.socket && this.socket_ready) {\n            if (this.heartbeat_out) clearTimeout(this.heartbeat_out);\n            this.transport.write(this.socket);\n            if (((this.is_closed() && this.state.has_settled()) || this.abort_idle || this.transport_error) && !this.transport.has_writes_pending()) {\n                this.socket.end();\n            } else if (this.is_open() && this.remote.open.idle_time_out) {\n                this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);\n            }\n            if (this.local.open.idle_time_out && this.heartbeat_in === undefined) {\n                this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);\n            }\n        }\n    } catch (e) {\n        this.saved_error = e;\n        if (e.name === 'ProtocolError') {\n            console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details() + ' ' + e.name);\n            this.dispatch('protocol_error', e) || console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details());\n        } else {\n            this.dispatch('error', e);\n        }\n        this.socket.end();\n    }\n};\n\nfunction byte_to_hex(value) {\n    if (value < 16) return '0x0' + Number(value).toString(16);\n    else return '0x' + Number(value).toString(16);\n}\n\nfunction buffer_to_hex(buffer) {\n    var bytes = [];\n    for (var i = 0; i < buffer.length; i++) {\n        bytes.push(byte_to_hex(buffer[i]));\n    }\n    return bytes.join(',');\n}\n\nConnection.prototype.input = function (buff) {\n    var buffer;\n    try {\n        if (this.heartbeat_in) clearTimeout(this.heartbeat_in);\n        log.io('[%s] read %d bytes', this.options.id, buff.length);\n        if (this.frame_size) {\n            this.received_bytes += buff.length;\n            this.chunks.push(buff);\n            if (this.frame_size <= this.received_bytes) {\n                buffer = Buffer.concat(this.chunks, this.received_bytes);\n                this.chunks = null;\n                this.frame_size = undefined;\n            } else {\n                log.io('[%s] pushed %d bytes', this.options.id, buff.length);\n                return;\n            }\n        } else if (this.previous_input) {\n            buffer = Buffer.concat([this.previous_input, buff]);\n            this.previous_input = null;\n        } else {\n            buffer = buff;\n        }\n        const read = this.transport.read(buffer, this);\n        if (read < buffer.length) {\n            const previous_input = buffer.slice(read);\n            this.frame_size = this.transport.peek_size(previous_input);\n            if (this.frame_size) {\n                this.chunks = [previous_input];\n                this.received_bytes = previous_input.length;\n                log.io('[%s] waiting frame_size %s', this.options.id, this.frame_size);\n            } else {\n                this.previous_input = previous_input;\n            }\n        }\n        if (this.local.open.idle_time_out) this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);\n        if (this.transport.has_writes_pending()) {\n            this.output();\n        } else if (this.is_closed() && this.state.has_settled()) {\n            this.socket.end();\n        } else if (this.is_open() && this.remote.open.idle_time_out && !this.heartbeat_out) {\n            this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);\n        }\n    } catch (e) {\n        this.saved_error = e;\n        if (e.name === 'ProtocolError') {\n            this.dispatch('protocol_error', e) ||\n                console.error('[' + this.options.id + '] error on read: ' + e + ' ' + this._get_peer_details() + ' (buffer:' + buffer_to_hex(buffer) + ')');\n        } else {\n            this.dispatch('error', e);\n        }\n        this.socket.end();\n    }\n\n};\n\nConnection.prototype.idle = function () {\n    if (!this.is_closed()) {\n        this.closed_with_non_fatal_error = true;\n        this.local.close.error = {condition:'amqp:resource-limit-exceeded', description:'max idle time exceeded'};\n        this.close();\n        this.abort_idle = setTimeout(this.abort_socket.bind(this, this.socket), 1000);\n    }\n};\n\nConnection.prototype.on_error = function (e) {\n    this._disconnected(e);\n};\n\nConnection.prototype.eof = function (e) {\n    var error = e || this.saved_error;\n    this.saved_error = undefined;\n    this._disconnected(error);\n};\n\nConnection.prototype._disconnected = function (error) {\n    if (this.heartbeat_out) {\n        clearTimeout(this.heartbeat_out);\n        this.heartbeat_out = undefined;\n    }\n    if (this.heartbeat_in) {\n        clearTimeout(this.heartbeat_in);\n        this.heartbeat_in = undefined;\n    }\n    if (this.abort_idle) {\n        clearTimeout(this.abort_idle);\n        this.abort_idle = undefined;\n    }\n    var was_closed_with_non_fatal_error = this.closed_with_non_fatal_error;\n    if (this.closed_with_non_fatal_error) {\n        this.closed_with_non_fatal_error = false;\n        if (this.options.reconnect) this.open();\n    }\n    if ((!this.is_closed() || was_closed_with_non_fatal_error) && this.scheduled_reconnect === undefined) {\n        this._disconnect();\n        var disconnect_ctxt = {};\n        if (error) {\n            disconnect_ctxt.error = error;\n        }\n        if (!this.is_server && !this.transport_error && this.options.reconnect) {\n            var delay = this.options.reconnect(this.conn_established_counter);\n            if (delay >= 0) {\n                log.reconnect('[%s] Scheduled reconnect in ' + delay + 'ms', this.options.id);\n                this.scheduled_reconnect = setTimeout(this.reconnect.bind(this), delay);\n                disconnect_ctxt.reconnecting = true;\n            } else {\n                disconnect_ctxt.reconnecting = false;\n            }\n        }\n        if (!this.dispatch('disconnected', this._context(disconnect_ctxt))) {\n            console.warn('[' + this.options.id + '] disconnected %s', disconnect_ctxt.error || '');\n        }\n    }\n};\n\nConnection.prototype.open = function () {\n    if (this.state.open()) {\n        this._register();\n    }\n};\n\nConnection.prototype.close = function (error) {\n    if (error) this.local.close.error = error;\n    if (this.state.close()) {\n        this._register();\n    }\n};\n\nConnection.prototype.is_open = function () {\n    return this.state.is_open();\n};\n\nConnection.prototype.is_remote_open = function () {\n    return this.state.remote_open;\n};\n\nConnection.prototype.is_closed = function () {\n    return this.state.is_closed();\n};\n\nConnection.prototype.create_session = function () {\n    var i = 0;\n    while (this.local_channel_map[i]) i++;\n    var session = new Session(this, i);\n    this.local_channel_map[i] = session;\n    return session;\n};\n\nConnection.prototype.find_sender = function (filter) {\n    return this.find_link(util.sender_filter(filter));\n};\n\nConnection.prototype.find_receiver = function (filter) {\n    return this.find_link(util.receiver_filter(filter));\n};\n\nConnection.prototype.find_link = function (filter) {\n    for (var channel in this.local_channel_map) {\n        var session = this.local_channel_map[channel];\n        var result = session.find_link(filter);\n        if (result) return result;\n    }\n    return undefined;\n};\n\nConnection.prototype.each_receiver = function (action, filter) {\n    this.each_link(action, util.receiver_filter(filter));\n};\n\nConnection.prototype.each_sender = function (action, filter) {\n    this.each_link(action, util.sender_filter(filter));\n};\n\nConnection.prototype.each_link = function (action, filter) {\n    for (var channel in this.local_channel_map) {\n        var session = this.local_channel_map[channel];\n        session.each_link(action, filter);\n    }\n};\n\nConnection.prototype.on_open = function (frame) {\n    if (this.state.remote_opened()) {\n        this.remote.open = frame.performative;\n        this.open();\n        this.dispatch('connection_open', this._context());\n    } else {\n        throw new errors.ProtocolError('Open already received');\n    }\n};\n\nConnection.prototype.on_close = function (frame) {\n    if (this.state.remote_closed()) {\n        this.remote.close = frame.performative;\n        if (this.remote.close.error) {\n            this._handle_error();\n        } else {\n            this.dispatch('connection_close', this._context());\n        }\n        if (this.heartbeat_out) clearTimeout(this.heartbeat_out);\n        var self = this;\n        process.nextTick(function () {\n            self.close();\n        });\n    } else {\n        throw new errors.ProtocolError('Close already received');\n    }\n};\n\nConnection.prototype._register = function () {\n    if (!this.registered) {\n        this.registered = true;\n        process.nextTick(this._process.bind(this));\n    }\n};\n\nConnection.prototype._process = function () {\n    this.registered = false;\n    do {\n        if (this.state.need_open()) {\n            this._write_open();\n        }\n        var localChannelMap = this.local_channel_map;\n        for (var k in localChannelMap) {\n            localChannelMap[k]._process();\n        }\n        if (this.state.need_close()) {\n            this._write_close();\n        }\n    } while (!this.state.has_settled());\n};\n\nConnection.prototype._write_frame = function (channel, frame, payload) {\n    this.amqp_transport.encode(frames.amqp_frame(channel, frame, payload));\n    this.output();\n};\n\nConnection.prototype._write_open = function () {\n    this._write_frame(0, this.local.open);\n};\n\nConnection.prototype._write_close = function () {\n    this._write_frame(0, this.local.close);\n    this.local.close.error = undefined;\n};\n\nConnection.prototype.on_begin = function (frame) {\n    var session;\n    if (frame.performative.remote_channel === null || frame.performative.remote_channel === undefined) {\n        //peer initiated\n        session = this.create_session();\n        session.local.begin.remote_channel = frame.channel;\n    } else {\n        session = this.local_channel_map[frame.performative.remote_channel];\n        if (!session) throw new errors.ProtocolError('Invalid value for remote channel ' + frame.performative.remote_channel);\n    }\n    session.on_begin(frame);\n    this.remote_channel_map[frame.channel] = session;\n};\n\nConnection.prototype.get_peer_certificate = function() {\n    if (this.socket && this.socket.getPeerCertificate) {\n        return this.socket.getPeerCertificate();\n    } else {\n        return undefined;\n    }\n};\n\nConnection.prototype.get_tls_socket = function() {\n    if (this.socket && (this.options.transport === 'tls' || this.options.transport === 'ssl')) {\n        return this.socket;\n    } else {\n        return undefined;\n    }\n};\n\nConnection.prototype._context = function (c) {\n    var context = c ? c : {};\n    context.connection = this;\n    if (this.container) context.container = this.container;\n    return context;\n};\n\nConnection.prototype.remove_session = function (session) {\n    if (this.remote_channel_map[session.remote.channel] === session) {\n        delete this.remote_channel_map[session.remote.channel];\n    }\n    if (this.local_channel_map[session.local.channel] === session) {\n        delete this.local_channel_map[session.local.channel];\n    }\n};\n\nConnection.prototype.remove_all_sessions = function () {\n    clearObject(this.remote_channel_map);\n    clearObject(this.local_channel_map);\n};\n\nfunction clearObject(obj) {\n    for (var k in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, k)) {\n            continue;\n        }\n        delete obj[k];\n    }\n}\n\nfunction delegate_to_session(name) {\n    Connection.prototype['on_' + name] = function (frame) {\n        var session = this.remote_channel_map[frame.channel];\n        if (!session) {\n            throw new errors.ProtocolError(name + ' received on invalid channel ' + frame.channel);\n        }\n        session['on_' + name](frame);\n    };\n}\n\ndelegate_to_session('end');\ndelegate_to_session('attach');\ndelegate_to_session('detach');\ndelegate_to_session('transfer');\ndelegate_to_session('disposition');\ndelegate_to_session('flow');\n\nmodule.exports = Connection;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar util = require('util');\n\nfunction ProtocolError(message) {\n    Error.captureStackTrace(this, ProtocolError);\n    this.message = message;\n    this.name = 'ProtocolError';\n}\nutil.inherits(ProtocolError, Error);\n\nfunction TypeError(message) {\n    Error.captureStackTrace(this, TypeError);\n    this.message = message;\n    this.name = 'TypeError';\n}\nutil.inherits(TypeError, ProtocolError);\n\nfunction ConnectionError(message, condition, connection) {\n    Error.captureStackTrace(this, ConnectionError);\n    this.message = message;\n    this.name = 'ConnectionError';\n    this.condition = condition;\n    this.description = message;\n    Object.defineProperty(this, 'connection', { value: connection });\n}\nutil.inherits(ConnectionError, Error);\n\nConnectionError.prototype.toJSON = function () {\n    return {\n        type: this.name,\n        code: this.condition,\n        message: this.description\n    };\n};\n\nmodule.exports = {\n    ProtocolError: ProtocolError,\n    TypeError: TypeError,\n    ConnectionError: ConnectionError\n};\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar errors = require('./errors.js');\n\nvar util = {};\n\nutil.allocate_buffer = function (size) {\n    return Buffer.alloc ? Buffer.alloc(size) : new Buffer(size);\n};\n\nutil.generate_uuid = function () {\n    return util.uuid_to_string(util.uuid4());\n};\n\nutil.uuid4 = function () {\n    var bytes = util.allocate_buffer(16);\n    for (var i = 0; i < bytes.length; i++) {\n        bytes[i] = Math.random()*255|0;\n    }\n\n    // From RFC4122, the version bits are set to 0100\n    bytes[7] &= 0x0F;\n    bytes[7] |= 0x40;\n\n    // From RFC4122, the top two bits of byte 8 get set to 01\n    bytes[8] &= 0x3F;\n    bytes[8] |= 0x80;\n\n    return bytes;\n};\n\n\nutil.uuid_to_string = function (buffer) {\n    if (buffer.length === 16) {\n        var chunks = [buffer.slice(0, 4), buffer.slice(4, 6), buffer.slice(6, 8), buffer.slice(8, 10), buffer.slice(10, 16)];\n        return chunks.map(function (b) { return b.toString('hex'); }).join('-');\n    } else {\n        throw new errors.TypeError('Not a UUID, expecting 16 byte buffer');\n    }\n};\n\nvar parse_uuid = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;\n\nutil.string_to_uuid = function (uuid_string) {\n    var parts = parse_uuid.exec(uuid_string.toLowerCase());\n    if (parts) {\n        return Buffer.from(parts.slice(1).join(''), 'hex');\n    } else {\n        throw new errors.TypeError('Not a valid UUID string: ' + uuid_string);\n    }\n};\n\nutil.clone = function (o) {\n    var copy = Object.create(o.prototype || {});\n    var names = Object.getOwnPropertyNames(o);\n    for (var i = 0; i < names.length; i++) {\n        var key = names[i];\n        copy[key] = o[key];\n    }\n    return copy;\n};\n\nutil.and = function (f, g) {\n    if (g === undefined) return f;\n    return function (o) {\n        return f(o) && g(o);\n    };\n};\n\nutil.is_sender = function (o) { return o.is_sender(); };\nutil.is_receiver = function (o) { return o.is_receiver(); };\nutil.sender_filter = function (filter) { return util.and(util.is_sender, filter); };\nutil.receiver_filter = function (filter) { return util.and(util.is_receiver, filter); };\n\nutil.is_defined = function (field) {\n    return field !== undefined && field !== null;\n};\n\nmodule.exports = util;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar types = require('./types.js');\nvar errors = require('./errors.js');\n\nvar frames = {};\nvar by_descriptor = {};\n\nframes.read_header = function(buffer) {\n    var offset = 4;\n    var header = {};\n    var name = buffer.toString('ascii', 0, offset);\n    if (name !== 'AMQP') {\n        // output name in hex (null-bytes can be tough to deal with in ascii)\n        throw new errors.ProtocolError('Invalid protocol header for AMQP: ' + buffer.toString('hex', 0, offset));\n    }\n    header.protocol_id = buffer.readUInt8(offset++);\n    header.major = buffer.readUInt8(offset++);\n    header.minor = buffer.readUInt8(offset++);\n    header.revision = buffer.readUInt8(offset++);\n    //the protocol header is interpreted in different ways for\n    //different versions(!); check some special cases to give clearer\n    //error messages:\n    if (header.protocol_id === 0 && header.major === 0 && header.minor === 9 && header.revision === 1) {\n        throw new errors.ProtocolError('Unsupported AMQP version: 0-9-1');\n    }\n    if (header.protocol_id === 1 && header.major === 1 && header.minor === 0 && header.revision === 10) {\n        throw new errors.ProtocolError('Unsupported AMQP version: 0-10');\n    }\n    if (header.major !== 1 || header.minor !== 0) {\n        throw new errors.ProtocolError('Unsupported AMQP version: ' + JSON.stringify(header));\n    }\n    return header;\n};\nframes.write_header = function(buffer, header) {\n    var offset = 4;\n    buffer.write('AMQP', 0, offset, 'ascii');\n    buffer.writeUInt8(header.protocol_id, offset++);\n    buffer.writeUInt8(header.major, offset++);\n    buffer.writeUInt8(header.minor, offset++);\n    buffer.writeUInt8(header.revision, offset++);\n    return 8;\n};\n//todo: define enumeration for frame types\nframes.TYPE_AMQP = 0x00;\nframes.TYPE_SASL = 0x01;\n\nframes.read_frame = function(buffer) {\n    var reader = new types.Reader(buffer);\n    var frame = {};\n    frame.size = reader.read_uint(4);\n    if (reader.remaining() < (frame.size-4)) {\n        return null;\n    }\n    var doff = reader.read_uint(1);\n    if (doff < 2) {\n        throw new errors.ProtocolError('Invalid data offset, must be at least 2 was ' + doff);\n    }\n    frame.type = reader.read_uint(1);\n    if (frame.type === frames.TYPE_AMQP) {\n        frame.channel = reader.read_uint(2);\n    } else if (frame.type === frames.TYPE_SASL) {\n        reader.skip(2);\n        frame.channel = 0;\n    } else {\n        throw new errors.ProtocolError('Unknown frame type ' + frame.type);\n    }\n    if (doff > 1) {\n        //ignore any extended header\n        reader.skip(doff * 4 - 8);\n    }\n    if (reader.remaining()) {\n        frame.performative = reader.read();\n        var c = by_descriptor[frame.performative.descriptor.value];\n        if (c) {\n            frame.performative = new c(frame.performative.value);\n        }\n        if (reader.remaining()) {\n            frame.payload = reader.read_bytes(reader.remaining());\n        }\n    }\n    return frame;\n};\n\nframes.write_frame = function(frame) {\n    var writer = new types.Writer();\n    writer.skip(4);//skip size until we know how much we have written\n    writer.write_uint(2, 1);//doff\n    writer.write_uint(frame.type, 1);\n    if (frame.type === frames.TYPE_AMQP) {\n        writer.write_uint(frame.channel, 2);\n    } else if (frame.type === frames.TYPE_SASL) {\n        writer.write_uint(0, 2);\n    } else {\n        throw new errors.ProtocolError('Unknown frame type ' + frame.type);\n    }\n    if (frame.performative) {\n        writer.write(frame.performative);\n        if (frame.payload) {\n            writer.write_bytes(frame.payload);\n        }\n    }\n    var buffer = writer.toBuffer();\n    buffer.writeUInt32BE(buffer.length, 0);//fill in the size\n    return buffer;\n};\n\nframes.amqp_frame = function(channel, performative, payload) {\n    return {'channel': channel || 0, 'type': frames.TYPE_AMQP, 'performative': performative, 'payload': payload};\n};\nframes.sasl_frame = function(performative) {\n    return {'channel': 0, 'type': frames.TYPE_SASL, 'performative': performative};\n};\n\nfunction define_frame(type, def) {\n    var c = types.define_composite(def);\n    frames[def.name] = c.create;\n    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;\n    by_descriptor[c.descriptor.symbolic] = c;\n}\n\nvar open = {\n    name: 'open',\n    code: 0x10,\n    fields: [\n        {name: 'container_id', type: 'string', mandatory: true},\n        {name: 'hostname', type: 'string'},\n        {name: 'max_frame_size', type: 'uint', default_value: 4294967295},\n        {name: 'channel_max', type: 'ushort', default_value: 65535},\n        {name: 'idle_time_out', type: 'uint'},\n        {name: 'outgoing_locales', type: 'symbol', multiple: true},\n        {name: 'incoming_locales', type: 'symbol', multiple: true},\n        {name: 'offered_capabilities', type: 'symbol', multiple: true},\n        {name: 'desired_capabilities', type: 'symbol', multiple: true},\n        {name: 'properties', type: 'symbolic_map'}\n    ]\n};\n\nvar begin = {\n    name: 'begin',\n    code: 0x11,\n    fields:[\n        {name: 'remote_channel', type: 'ushort'},\n        {name: 'next_outgoing_id', type: 'uint', mandatory: true},\n        {name: 'incoming_window', type: 'uint', mandatory: true},\n        {name: 'outgoing_window', type: 'uint', mandatory: true},\n        {name: 'handle_max', type: 'uint', default_value: '4294967295'},\n        {name: 'offered_capabilities', type: 'symbol', multiple: true},\n        {name: 'desired_capabilities', type: 'symbol', multiple: true},\n        {name: 'properties', type: 'symbolic_map'}\n    ]\n};\n\nvar attach = {\n    name: 'attach',\n    code: 0x12,\n    fields:[\n        {name: 'name', type: 'string', mandatory: true},\n        {name: 'handle', type: 'uint', mandatory: true},\n        {name: 'role', type: 'boolean', mandatory: true},\n        {name: 'snd_settle_mode', type: 'ubyte', default_value: 2},\n        {name: 'rcv_settle_mode', type: 'ubyte', default_value: 0},\n        {name: 'source', type: '*'},\n        {name: 'target', type: '*'},\n        {name: 'unsettled', type: 'map'},\n        {name: 'incomplete_unsettled', type: 'boolean', default_value: false},\n        {name: 'initial_delivery_count', type: 'uint'},\n        {name: 'max_message_size', type: 'ulong'},\n        {name: 'offered_capabilities', type: 'symbol', multiple: true},\n        {name: 'desired_capabilities', type: 'symbol', multiple: true},\n        {name: 'properties', type: 'symbolic_map'}\n    ]\n};\n\nvar flow = {\n    name: 'flow',\n    code: 0x13,\n    fields:[\n        {name: 'next_incoming_id', type: 'uint'},\n        {name: 'incoming_window', type: 'uint', mandatory: true},\n        {name: 'next_outgoing_id', type: 'uint', mandatory: true},\n        {name: 'outgoing_window', type: 'uint', mandatory: true},\n        {name: 'handle', type: 'uint'},\n        {name: 'delivery_count', type: 'uint'},\n        {name: 'link_credit', type: 'uint'},\n        {name: 'available', type: 'uint'},\n        {name: 'drain', type: 'boolean', default_value: false},\n        {name: 'echo', type: 'boolean', default_value: false},\n        {name: 'properties', type: 'symbolic_map'}\n    ]\n};\n\nvar transfer = {\n    name: 'transfer',\n    code: 0x14,\n    fields:[\n        {name: 'handle', type: 'uint', mandatory: true},\n        {name: 'delivery_id', type: 'uint'},\n        {name: 'delivery_tag', type: 'binary'},\n        {name: 'message_format', type: 'uint'},\n        {name: 'settled', type: 'boolean'},\n        {name: 'more', type: 'boolean', default_value: false},\n        {name: 'rcv_settle_mode', type: 'ubyte'},\n        {name: 'state', type: 'delivery_state'},\n        {name: 'resume', type: 'boolean', default_value: false},\n        {name: 'aborted', type: 'boolean', default_value: false},\n        {name: 'batchable', type: 'boolean', default_value: false}\n    ]\n};\n\nvar disposition = {\n    name: 'disposition',\n    code: 0x15,\n    fields:[\n        {name: 'role', type: 'boolean', mandatory: true},\n        {name: 'first', type: 'uint', mandatory: true},\n        {name: 'last', type: 'uint'},\n        {name: 'settled', type: 'boolean', default_value: false},\n        {name: 'state', type: '*'},\n        {name: 'batchable', type: 'boolean', default_value: false}\n    ]\n};\n\nvar detach = {\n    name: 'detach',\n    code: 0x16,\n    fields: [\n        {name: 'handle', type: 'uint', mandatory: true},\n        {name: 'closed', type: 'boolean', default_value: false},\n        {name: 'error', type: 'error'}\n    ]\n};\n\nvar end = {\n    name: 'end',\n    code: 0x17,\n    fields: [\n        {name: 'error', type: 'error'}\n    ]\n};\n\nvar close = {\n    name: 'close',\n    code: 0x18,\n    fields: [\n        {name: 'error', type: 'error'}\n    ]\n};\n\ndefine_frame(frames.TYPE_AMQP, open);\ndefine_frame(frames.TYPE_AMQP, begin);\ndefine_frame(frames.TYPE_AMQP, attach);\ndefine_frame(frames.TYPE_AMQP, flow);\ndefine_frame(frames.TYPE_AMQP, transfer);\ndefine_frame(frames.TYPE_AMQP, disposition);\ndefine_frame(frames.TYPE_AMQP, detach);\ndefine_frame(frames.TYPE_AMQP, end);\ndefine_frame(frames.TYPE_AMQP, close);\n\nvar sasl_mechanisms = {\n    name: 'sasl_mechanisms',\n    code: 0x40,\n    fields: [\n        {name: 'sasl_server_mechanisms', type: 'symbol', multiple: true, mandatory: true}\n    ]\n};\n\nvar sasl_init = {\n    name: 'sasl_init',\n    code: 0x41,\n    fields: [\n        {name: 'mechanism', type: 'symbol', mandatory: true},\n        {name: 'initial_response', type: 'binary'},\n        {name: 'hostname', type: 'string'}\n    ]\n};\n\nvar sasl_challenge = {\n    name: 'sasl_challenge',\n    code: 0x42,\n    fields: [\n        {name: 'challenge', type: 'binary', mandatory: true}\n    ]\n};\n\nvar sasl_response = {\n    name: 'sasl_response',\n    code: 0x43,\n    fields: [\n        {name: 'response', type: 'binary', mandatory: true}\n    ]\n};\n\nvar sasl_outcome = {\n    name: 'sasl_outcome',\n    code: 0x44,\n    fields: [\n        {name: 'code', type: 'ubyte', mandatory: true},\n        {name: 'additional_data', type: 'binary'}\n    ]\n};\n\ndefine_frame(frames.TYPE_SASL, sasl_mechanisms);\ndefine_frame(frames.TYPE_SASL, sasl_init);\ndefine_frame(frames.TYPE_SASL, sasl_challenge);\ndefine_frame(frames.TYPE_SASL, sasl_response);\ndefine_frame(frames.TYPE_SASL, sasl_outcome);\n\nmodule.exports = frames;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar errors = require('./errors.js');\nvar util = require('./util.js');\n\nvar CAT_FIXED = 1;\nvar CAT_VARIABLE = 2;\nvar CAT_COMPOUND = 3;\nvar CAT_ARRAY = 4;\n\nfunction Typed(type, value, code, descriptor) {\n    this.type = type;\n    this.value = value;\n    if (code) {\n        this.array_constructor = {'typecode':code};\n        if (descriptor) {\n            this.array_constructor.descriptor = descriptor;\n        }\n    }\n}\n\nTyped.prototype.toString = function() {\n    return this.value ? this.value.toString() : null;\n};\n\nTyped.prototype.toLocaleString = function() {\n    return this.value ? this.value.toLocaleString() : null;\n};\n\nTyped.prototype.valueOf = function() {\n    return this.value;\n};\n\nTyped.prototype.toJSON = function() {\n    return this.value && this.value.toJSON ? this.value.toJSON() : this.value;\n};\n\nTyped.prototype.toRheaTyped = function() {\n    return this;\n};\n\nfunction TypeDesc(name, typecode, props, empty_value) {\n    this.name = name;\n    this.typecode = typecode;\n    var subcategory = typecode >>> 4;\n    switch (subcategory) {\n    case 0x4:\n        this.width = 0;\n        this.category = CAT_FIXED;\n        break;\n    case 0x5:\n        this.width = 1;\n        this.category = CAT_FIXED;\n        break;\n    case 0x6:\n        this.width = 2;\n        this.category = CAT_FIXED;\n        break;\n    case 0x7:\n        this.width = 4;\n        this.category = CAT_FIXED;\n        break;\n    case 0x8:\n        this.width = 8;\n        this.category = CAT_FIXED;\n        break;\n    case 0x9:\n        this.width = 16;\n        this.category = CAT_FIXED;\n        break;\n    case 0xA:\n        this.width = 1;\n        this.category = CAT_VARIABLE;\n        break;\n    case 0xB:\n        this.width = 4;\n        this.category = CAT_VARIABLE;\n        break;\n    case 0xC:\n        this.width = 1;\n        this.category = CAT_COMPOUND;\n        break;\n    case 0xD:\n        this.width = 4;\n        this.category = CAT_COMPOUND;\n        break;\n    case 0xE:\n        this.width = 1;\n        this.category = CAT_ARRAY;\n        break;\n    case 0xF:\n        this.width = 4;\n        this.category = CAT_ARRAY;\n        break;\n    default:\n        //can't happen\n        break;\n    }\n\n    if (props) {\n        if (props.read) {\n            this.read = props.read;\n        }\n        if (props.write) {\n            this.write = props.write;\n        }\n        if (props.encoding) {\n            this.encoding = props.encoding;\n        }\n    }\n\n    var t = this;\n    if (subcategory === 0x4) {\n        // 'empty' types don't take a value\n        this.create = function () {\n            return new Typed(t, empty_value);\n        };\n    } else if (subcategory === 0xE || subcategory === 0xF) {\n        this.create = function (v, code, descriptor) {\n            return new Typed(t, v, code, descriptor);\n        };\n    } else {\n        this.create = function (v) {\n            return new Typed(t, v);\n        };\n    }\n}\n\nTypeDesc.prototype.toString = function () {\n    return this.name + '#' + hex(this.typecode);\n};\n\nfunction hex(i) {\n    return Number(i).toString(16);\n}\n\nvar types = {'by_code':{}};\nObject.defineProperty(types, 'MAX_UINT', {value: 4294967295, writable: false, configurable: false});\nObject.defineProperty(types, 'MAX_USHORT', {value: 65535, writable: false, configurable: false});\n\nfunction define_type(name, typecode, annotations, empty_value) {\n    var t = new TypeDesc(name, typecode, annotations, empty_value);\n    t.create.typecode = t.typecode;//hack\n    types.by_code[t.typecode] = t;\n    types[name] = t.create;\n}\n\nfunction buffer_uint8_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readUInt8(offset); },\n        'write': function (buffer, value, offset) { buffer.writeUInt8(value, offset); }\n    };\n}\n\nfunction buffer_uint16be_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readUInt16BE(offset); },\n        'write': function (buffer, value, offset) { buffer.writeUInt16BE(value, offset); }\n    };\n}\n\nfunction buffer_uint32be_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readUInt32BE(offset); },\n        'write': function (buffer, value, offset) { buffer.writeUInt32BE(value, offset); }\n    };\n}\n\nfunction buffer_int8_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readInt8(offset); },\n        'write': function (buffer, value, offset) { buffer.writeInt8(value, offset); }\n    };\n}\n\nfunction buffer_int16be_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readInt16BE(offset); },\n        'write': function (buffer, value, offset) { buffer.writeInt16BE(value, offset); }\n    };\n}\n\nfunction buffer_int32be_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readInt32BE(offset); },\n        'write': function (buffer, value, offset) { buffer.writeInt32BE(value, offset); }\n    };\n}\n\nfunction buffer_floatbe_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readFloatBE(offset); },\n        'write': function (buffer, value, offset) { buffer.writeFloatBE(value, offset); }\n    };\n}\n\nfunction buffer_doublebe_ops() {\n    return {\n        'read': function (buffer, offset) { return buffer.readDoubleBE(offset); },\n        'write': function (buffer, value, offset) { buffer.writeDoubleBE(value, offset); }\n    };\n}\n\nvar MAX_UINT = 4294967296; // 2^32\nvar MIN_INT = -2147483647;\nfunction write_ulong(buffer, value, offset) {\n    if ((typeof value) === 'number' || value instanceof Number) {\n        var hi = Math.floor(value / MAX_UINT);\n        var lo = value % MAX_UINT;\n        buffer.writeUInt32BE(hi, offset);\n        buffer.writeUInt32BE(lo, offset + 4);\n    } else {\n        value.copy(buffer, offset);\n    }\n}\n\nfunction read_ulong(buffer, offset) {\n    var hi = buffer.readUInt32BE(offset);\n    var lo = buffer.readUInt32BE(offset + 4);\n    if (hi < 2097153) {\n        return hi * MAX_UINT + lo;\n    } else {\n        return buffer.slice(offset, offset + 8);\n    }\n}\n\nfunction write_long(buffer, value, offset) {\n    if ((typeof value) === 'number' || value instanceof Number) {\n        var abs = Math.abs(value);\n        var hi = Math.floor(abs / MAX_UINT);\n        var lo = abs % MAX_UINT;\n        buffer.writeInt32BE(hi, offset);\n        buffer.writeUInt32BE(lo, offset + 4);\n        if (value < 0) {\n            var carry = 1;\n            for (var i = 0; i < 8; i++) {\n                var index = offset + (7 - i);\n                var v = (buffer[index] ^ 0xFF) + carry;\n                buffer[index] = v & 0xFF;\n                carry = v >> 8;\n            }\n        }\n    } else {\n        value.copy(buffer, offset);\n    }\n}\n\nfunction write_timestamp(buffer, value, offset) {\n    if (typeof value === 'object' && value !== null && typeof value.getTime === 'function') {\n        value = value.getTime();\n    }\n    return write_long(buffer, value, offset);\n}\n\nfunction read_long(buffer, offset) {\n    var hi = buffer.readInt32BE(offset);\n    var lo = buffer.readUInt32BE(offset + 4);\n    if (hi < 2097153 && hi > -2097153) {\n        return hi * MAX_UINT + lo;\n    } else {\n        return buffer.slice(offset, offset + 8);\n    }\n}\n\nfunction read_timestamp(buffer, offset) {\n    const l = read_long(buffer, offset);\n    return new Date(l);\n}\n\ndefine_type('Null', 0x40, undefined, null);\ndefine_type('Boolean', 0x56, buffer_uint8_ops());\ndefine_type('True', 0x41, undefined, true);\ndefine_type('False', 0x42, undefined, false);\ndefine_type('Ubyte', 0x50, buffer_uint8_ops());\ndefine_type('Ushort', 0x60, buffer_uint16be_ops());\ndefine_type('Uint', 0x70, buffer_uint32be_ops());\ndefine_type('SmallUint', 0x52, buffer_uint8_ops());\ndefine_type('Uint0', 0x43, undefined, 0);\ndefine_type('Ulong', 0x80, {'write':write_ulong, 'read':read_ulong});\ndefine_type('SmallUlong', 0x53, buffer_uint8_ops());\ndefine_type('Ulong0', 0x44, undefined, 0);\ndefine_type('Byte', 0x51, buffer_int8_ops());\ndefine_type('Short', 0x61, buffer_int16be_ops());\ndefine_type('Int', 0x71, buffer_int32be_ops());\ndefine_type('SmallInt', 0x54, buffer_int8_ops());\ndefine_type('Long', 0x81, {'write':write_long, 'read':read_long});\ndefine_type('SmallLong', 0x55, buffer_int8_ops());\ndefine_type('Float', 0x72, buffer_floatbe_ops());\ndefine_type('Double', 0x82, buffer_doublebe_ops());\ndefine_type('Decimal32', 0x74);\ndefine_type('Decimal64', 0x84);\ndefine_type('Decimal128', 0x94);\ndefine_type('CharUTF32', 0x73, buffer_uint32be_ops());\ndefine_type('Timestamp', 0x83, {'write':write_timestamp, 'read':read_timestamp});\ndefine_type('Uuid', 0x98);//TODO: convert to/from stringified form?\ndefine_type('Vbin8', 0xa0);\ndefine_type('Vbin32', 0xb0);\ndefine_type('Str8', 0xa1, {'encoding':'utf8'});\ndefine_type('Str32', 0xb1, {'encoding':'utf8'});\ndefine_type('Sym8', 0xa3, {'encoding':'ascii'});\ndefine_type('Sym32', 0xb3, {'encoding':'ascii'});\ndefine_type('List0', 0x45, undefined, []);\ndefine_type('List8', 0xc0);\ndefine_type('List32', 0xd0);\ndefine_type('Map8', 0xc1);\ndefine_type('Map32', 0xd1);\ndefine_type('Array8', 0xe0);\ndefine_type('Array32', 0xf0);\n\nfunction is_one_of(o, typelist) {\n    for (var i = 0; i < typelist.length; i++) {\n        if (o.type.typecode === typelist[i].typecode) return true;\n    }\n    return false;\n}\nfunction buffer_zero(b, len, neg) {\n    for (var i = 0; i < len && i < b.length; i++) {\n        if (b[i] !== (neg ? 0xff : 0)) return false;\n    }\n    return true;\n}\ntypes.is_ulong = function(o) {\n    return is_one_of(o, [types.Ulong, types.Ulong0, types.SmallUlong]);\n};\ntypes.is_string = function(o) {\n    return is_one_of(o, [types.Str8, types.Str32]);\n};\ntypes.is_symbol = function(o) {\n    return is_one_of(o, [types.Sym8, types.Sym32]);\n};\ntypes.is_list = function(o) {\n    return is_one_of(o, [types.List0, types.List8, types.List32]);\n};\ntypes.is_map = function(o) {\n    return is_one_of(o, [types.Map8, types.Map32]);\n};\n\ntypes.wrap_boolean = function(v) {\n    return v ? types.True() : types.False();\n};\ntypes.wrap_ulong = function(l) {\n    if (Buffer.isBuffer(l)) {\n        if (buffer_zero(l, 8, false)) return types.Ulong0();\n        return buffer_zero(l, 7, false) ? types.SmallUlong(l[7]) : types.Ulong(l);\n    } else {\n        if (l === 0) return types.Ulong0();\n        else return l > 255 ? types.Ulong(l) : types.SmallUlong(l);\n    }\n};\ntypes.wrap_uint = function(l) {\n    if (l === 0) return types.Uint0();\n    else return l > 255 ? types.Uint(l) : types.SmallUint(l);\n};\ntypes.wrap_ushort = function(l) {\n    return types.Ushort(l);\n};\ntypes.wrap_ubyte = function(l) {\n    return types.Ubyte(l);\n};\ntypes.wrap_long = function(l) {\n    if (Buffer.isBuffer(l)) {\n        var negFlag = (l[0] & 0x80) !== 0;\n        if (buffer_zero(l, 7, negFlag) && (l[7] & 0x80) === (negFlag ? 0x80 : 0)) {\n            return types.SmallLong(negFlag ? -((l[7] ^ 0xff) + 1) : l[7]);\n        }\n        return types.Long(l);\n    } else {\n        return l > 127 || l < -128 ? types.Long(l) : types.SmallLong(l);\n    }\n};\ntypes.wrap_int = function(l) {\n    return l > 127 || l < -128 ? types.Int(l) : types.SmallInt(l);\n};\ntypes.wrap_short = function(l) {\n    return types.Short(l);\n};\ntypes.wrap_byte = function(l) {\n    return types.Byte(l);\n};\ntypes.wrap_float = function(l) {\n    return types.Float(l);\n};\ntypes.wrap_double = function(l) {\n    return types.Double(l);\n};\ntypes.wrap_timestamp = function(l) {\n    return types.Timestamp(l);\n};\ntypes.wrap_char = function(v) {\n    return types.CharUTF32(v);\n};\ntypes.wrap_uuid = function(v) {\n    return types.Uuid(v);\n};\ntypes.wrap_binary = function (s) {\n    return s.length > 255 ? types.Vbin32(s) : types.Vbin8(s);\n};\ntypes.wrap_string = function (s) {\n    return Buffer.byteLength(s) > 255 ? types.Str32(s) : types.Str8(s);\n};\ntypes.wrap_symbol = function (s) {\n    return Buffer.byteLength(s) > 255 ? types.Sym32(s) : types.Sym8(s);\n};\ntypes.wrap_list = function(l) {\n    if (l.length === 0) return types.List0();\n    var items = l.map(types.wrap);\n    return types.List32(items);\n};\ntypes.wrap_set_as_list = function(l) {\n    if (l.size === 0) return types.List0();\n    var items = Array.from(l, types.wrap);\n    return types.List32(items);\n};\ntypes.wrap_map = function(m, key_wrapper) {\n    var items = [];\n    for (var k in m) {\n        items.push(key_wrapper ? key_wrapper(k) : types.wrap(k));\n        items.push(types.wrap(m[k]));\n    }\n    return types.Map32(items);\n};\ntypes.wrap_map_as_map = function(m) {\n    var items = [];\n    for (var [k, v] of m) {\n        items.push(types.wrap(k));\n        items.push(types.wrap(v));\n    }\n    return types.Map32(items);\n};\ntypes.wrap_symbolic_map = function(m) {\n    return types.wrap_map(m, types.wrap_symbol);\n};\ntypes.wrap_array = function(l, code, descriptors) {\n    if (code) {\n        return types.Array32(l, code, descriptors);\n    } else {\n        console.trace('An array must specify a type for its elements');\n        throw new errors.TypeError('An array must specify a type for its elements');\n    }\n};\ntypes.wrap = function(o) {\n    var t = typeof o;\n    if (t === 'object' && o !== null && typeof o.toRheaTyped === 'function') {\n        return o.toRheaTyped();\n    } else if (t === 'string') {\n        return types.wrap_string(o);\n    } else if (t === 'boolean') {\n        return o ? types.True() : types.False();\n    } else if (t === 'number' || o instanceof Number) {\n        if (isNaN(o)) {\n            return types.Null();\n        } else if (Math.floor(o) - o !== 0) {\n            return types.Double(o);\n        } else if (o > 0) {\n            if (o < MAX_UINT) {\n                return types.wrap_uint(o);\n            } else {\n                return types.wrap_ulong(o);\n            }\n        } else {\n            if (o > MIN_INT) {\n                return types.wrap_int(o);\n            } else {\n                return types.wrap_long(o);\n            }\n        }\n    } else if (o instanceof Date) {\n        return types.wrap_timestamp(o.getTime());\n    } else if (o instanceof Buffer || o instanceof Uint8Array) {\n        return types.wrap_binary(o);\n    } else if (t === 'undefined' || o === null) {\n        return types.Null();\n    } else if (Array.isArray(o)) {\n        return types.wrap_list(o);\n    } else if (o instanceof Map) {\n        return types.wrap_map_as_map(o);\n    } else if (o instanceof Set) {\n        return types.wrap_set_as_list(o);\n    } else {\n        return types.wrap_map(o);\n    }\n};\n\ntypes.wrap_described = function(value, descriptor) {\n    var result = types.wrap(value);\n    if (descriptor) {\n        if (typeof descriptor === 'string') {\n            result = types.described(types.wrap_symbol(descriptor), result);\n        } else if (typeof descriptor === 'number' || descriptor instanceof Number) {\n            result = types.described(types.wrap_ulong(descriptor), result);\n        }\n    }\n    return result;\n};\n\ntypes.wrap_message_id = function(o) {\n    var t = typeof o;\n    if (t === 'string') {\n        return types.wrap_string(o);\n    } else if (t === 'number' || o instanceof Number) {\n        return types.wrap_ulong(o);\n    } else if (Buffer.isBuffer(o)) {\n        return types.wrap_uuid(o);\n    } else if (o instanceof Typed) {\n        return o;\n    } else {\n        //TODO handle uuids\n        throw new errors.TypeError('invalid message id:' + o);\n    }\n};\n\n/**\n * Converts the list of keys and values that comprise an AMQP encoded\n * map into a proper javascript map/object.\n */\nfunction mapify(elements) {\n    var result = {};\n    for (var i = 0; i+1 < elements.length;) {\n        result[elements[i++]] = elements[i++];\n    }\n    return result;\n}\n\nvar by_descriptor = {};\n\ntypes.unwrap_map_simple = function(o) {\n    return mapify(o.value.map(function (i) { return types.unwrap(i, true); }));\n};\n\ntypes.unwrap = function(o, leave_described) {\n    if (o instanceof Typed) {\n        if (o.descriptor) {\n            var c = by_descriptor[o.descriptor.value];\n            if (c) {\n                return new c(o.value);\n            } else if (leave_described) {\n                return o;\n            }\n        }\n        var u = types.unwrap(o.value, true);\n        return types.is_map(o) ? mapify(u) : u;\n    } else if (Array.isArray(o)) {\n        return o.map(function (i) { return types.unwrap(i, true); });\n    } else {\n        return o;\n    }\n};\n\n/*\ntypes.described = function (descriptor, typedvalue) {\n    var o = Object.create(typedvalue);\n    if (descriptor.length) {\n        o.descriptor = descriptor.shift();\n        return types.described(descriptor, o);\n    } else {\n        o.descriptor = descriptor;\n        return o;\n    }\n};\n*/\ntypes.described_nc = function (descriptor, o) {\n    if (descriptor.length) {\n        o.descriptor = descriptor.shift();\n        return types.described(descriptor, o);\n    } else {\n        o.descriptor = descriptor;\n        return o;\n    }\n};\ntypes.described = types.described_nc;\n\nfunction get_type(code) {\n    var type = types.by_code[code];\n    if (!type) {\n        throw new errors.TypeError('Unrecognised typecode: ' + hex(code));\n    }\n    return type;\n}\n\ntypes.Reader = function (buffer) {\n    this.buffer = buffer;\n    this.position = 0;\n};\n\ntypes.Reader.prototype.read_typecode = function () {\n    return this.read_uint(1);\n};\n\ntypes.Reader.prototype.read_uint = function (width) {\n    var current = this.position;\n    this.position += width;\n    if (width === 1) {\n        return this.buffer.readUInt8(current);\n    } else if (width === 2) {\n        return this.buffer.readUInt16BE(current);\n    } else if (width === 4) {\n        return this.buffer.readUInt32BE(current);\n    } else {\n        throw new errors.TypeError('Unexpected width for uint ' + width);\n    }\n};\n\ntypes.Reader.prototype.read_fixed_width = function (type) {\n    var current = this.position;\n    this.position += type.width;\n    if (type.read) {\n        return type.read(this.buffer, current);\n    } else {\n        return this.buffer.slice(current, this.position);\n    }\n};\n\ntypes.Reader.prototype.read_variable_width = function (type) {\n    var size = this.read_uint(type.width);\n    var slice = this.read_bytes(size);\n    return type.encoding ? slice.toString(type.encoding) : slice;\n};\n\ntypes.Reader.prototype.read = function () {\n    var constructor = this.read_constructor();\n    var value = this.read_value(get_type(constructor.typecode));\n    return constructor.descriptor ? types.described_nc(constructor.descriptor, value) : value;\n};\n\ntypes.Reader.prototype.read_constructor = function (descriptors) {\n    var code = this.read_typecode();\n    if (code === 0x00) {\n        if (descriptors === undefined) {\n            descriptors = [];\n        }\n        descriptors.push(this.read());\n        return this.read_constructor(descriptors);\n    } else {\n        if (descriptors === undefined) {\n            return {'typecode': code};\n        } else if (descriptors.length === 1) {\n            return {'typecode': code, 'descriptor':  descriptors[0]};\n        } else {\n            return {'typecode': code, 'descriptor':  descriptors[0], 'descriptors': descriptors};\n        }\n    }\n};\n\ntypes.Reader.prototype.read_value = function (type) {\n    if (type.width === 0) {\n        return type.create();\n    } else if (type.category === CAT_FIXED) {\n        return type.create(this.read_fixed_width(type));\n    } else if (type.category === CAT_VARIABLE) {\n        return type.create(this.read_variable_width(type));\n    } else if (type.category === CAT_COMPOUND) {\n        return this.read_compound(type);\n    } else if (type.category === CAT_ARRAY) {\n        return this.read_array(type);\n    } else {\n        throw new errors.TypeError('Invalid category for type: ' + type);\n    }\n};\n\ntypes.Reader.prototype.read_array_items = function (n, type) {\n    var items = [];\n    while (items.length < n) {\n        items.push(this.read_value(type));\n    }\n    return items;\n};\n\ntypes.Reader.prototype.read_n = function (n) {\n    var items = new Array(n);\n    for (var i = 0; i < n; i++) {\n        items[i] = this.read();\n    }\n    return items;\n};\n\ntypes.Reader.prototype.read_size_count = function (width) {\n    return {'size': this.read_uint(width), 'count': this.read_uint(width)};\n};\n\ntypes.Reader.prototype.read_compound = function (type) {\n    var limits = this.read_size_count(type.width);\n    return type.create(this.read_n(limits.count));\n};\n\ntypes.Reader.prototype.read_array = function (type) {\n    var limits = this.read_size_count(type.width);\n    var constructor = this.read_constructor();\n    return type.create(this.read_array_items(limits.count, get_type(constructor.typecode)), constructor.typecode, constructor.descriptor);\n};\n\ntypes.Reader.prototype.toString = function () {\n    var s = 'buffer@' + this.position;\n    if (this.position) s += ': ';\n    for (var i = this.position; i < this.buffer.length; i++) {\n        if (i > 0) s+= ',';\n        s += '0x' + Number(this.buffer[i]).toString(16);\n    }\n    return s;\n};\n\ntypes.Reader.prototype.reset = function () {\n    this.position = 0;\n};\n\ntypes.Reader.prototype.skip = function (bytes) {\n    this.position += bytes;\n};\n\ntypes.Reader.prototype.read_bytes = function (bytes) {\n    var current = this.position;\n    this.position += bytes;\n    return this.buffer.slice(current, this.position);\n};\n\ntypes.Reader.prototype.remaining = function () {\n    return this.buffer.length - this.position;\n};\n\ntypes.Writer = function (buffer) {\n    this.buffer = buffer ? buffer : util.allocate_buffer(1024);\n    this.position = 0;\n};\n\ntypes.Writer.prototype.toBuffer = function () {\n    return this.buffer.slice(0, this.position);\n};\n\nfunction max(a, b) {\n    return a > b ? a : b;\n}\n\ntypes.Writer.prototype.ensure = function (length) {\n    if (this.buffer.length < length) {\n        var bigger = util.allocate_buffer(max(this.buffer.length*2, length));\n        this.buffer.copy(bigger);\n        this.buffer = bigger;\n    }\n};\n\ntypes.Writer.prototype.write_typecode = function (code) {\n    this.write_uint(code, 1);\n};\n\ntypes.Writer.prototype.write_uint = function (value, width) {\n    var current = this.position;\n    this.ensure(this.position + width);\n    this.position += width;\n    if (width === 1) {\n        return this.buffer.writeUInt8(value, current);\n    } else if (width === 2) {\n        return this.buffer.writeUInt16BE(value, current);\n    } else if (width === 4) {\n        return this.buffer.writeUInt32BE(value, current);\n    } else {\n        throw new errors.TypeError('Unexpected width for uint ' + width);\n    }\n};\n\n\ntypes.Writer.prototype.write_fixed_width = function (type, value) {\n    var current = this.position;\n    this.ensure(this.position + type.width);\n    this.position += type.width;\n    if (type.write) {\n        type.write(this.buffer, value, current);\n    } else if (value.copy) {\n        value.copy(this.buffer, current);\n    } else {\n        throw new errors.TypeError('Cannot handle write for ' + type);\n    }\n};\n\ntypes.Writer.prototype.write_variable_width = function (type, value) {\n    var source = type.encoding ? Buffer.from(value, type.encoding) : Buffer.from(value);//TODO: avoid creating new buffers\n    this.write_uint(source.length, type.width);\n    this.write_bytes(source);\n};\n\ntypes.Writer.prototype.write_bytes = function (source) {\n    var current = this.position;\n    this.ensure(this.position + source.length);\n    this.position += source.length;\n    source.copy(this.buffer, current);\n};\n\ntypes.Writer.prototype.write_constructor = function (typecode, descriptor) {\n    if (descriptor) {\n        this.write_typecode(0x00);\n        this.write(descriptor);\n    }\n    this.write_typecode(typecode);\n};\n\ntypes.Writer.prototype.write = function (o) {\n    if (o.type === undefined) {\n        if (o.described) {\n            this.write(o.described());\n        } else {\n            throw new errors.TypeError('Cannot write ' + JSON.stringify(o));\n        }\n    } else {\n        this.write_constructor(o.type.typecode, o.descriptor);\n        this.write_value(o.type, o.value, o.array_constructor);\n    }\n};\n\ntypes.Writer.prototype.write_value = function (type, value, constructor/*for arrays only*/) {\n    if (type.width === 0) {\n        return;//nothing further to do\n    } else if (type.category === CAT_FIXED) {\n        this.write_fixed_width(type, value);\n    } else if (type.category === CAT_VARIABLE) {\n        this.write_variable_width(type, value);\n    } else if (type.category === CAT_COMPOUND) {\n        this.write_compound(type, value);\n    } else if (type.category === CAT_ARRAY) {\n        this.write_array(type, value, constructor);\n    } else {\n        throw new errors.TypeError('Invalid category ' + type.category + ' for type: ' + type);\n    }\n};\n\ntypes.Writer.prototype.backfill_size = function (width, saved) {\n    var gap = this.position - saved;\n    this.position = saved;\n    this.write_uint(gap - width, width);\n    this.position += (gap - width);\n};\n\ntypes.Writer.prototype.write_compound = function (type, value) {\n    var saved = this.position;\n    this.position += type.width;//skip size field\n    this.write_uint(value.length, type.width);//count field\n    for (var i = 0; i < value.length; i++) {\n        if (value[i] === undefined || value[i] === null) {\n            this.write(types.Null());\n        } else {\n            this.write(value[i]);\n        }\n    }\n    this.backfill_size(type.width, saved);\n};\n\ntypes.Writer.prototype.write_array = function (type, value, constructor) {\n    var saved = this.position;\n    this.position += type.width;//skip size field\n    this.write_uint(value.length, type.width);//count field\n    this.write_constructor(constructor.typecode, constructor.descriptor);\n    var ctype = get_type(constructor.typecode);\n    for (var i = 0; i < value.length; i++) {\n        this.write_value(ctype, value[i]);\n    }\n    this.backfill_size(type.width, saved);\n};\n\ntypes.Writer.prototype.toString = function () {\n    var s = 'buffer@' + this.position;\n    if (this.position) s += ': ';\n    for (var i = 0; i < this.position; i++) {\n        if (i > 0) s+= ',';\n        s += ('00' + Number(this.buffer[i]).toString(16)).slice(-2);\n    }\n    return s;\n};\n\ntypes.Writer.prototype.skip = function (bytes) {\n    this.ensure(this.position + bytes);\n    this.position += bytes;\n};\n\ntypes.Writer.prototype.clear = function () {\n    this.buffer.fill(0x00);\n    this.position = 0;\n};\n\ntypes.Writer.prototype.remaining = function () {\n    return this.buffer.length - this.position;\n};\n\n\nfunction get_constructor(typename) {\n    if (typename === 'symbol') {\n        return {typecode:types.Sym8.typecode};\n    }\n    throw new errors.TypeError('TODO: Array of type ' + typename + ' not yet supported');\n}\n\nfunction wrap_field(definition, instance) {\n    if (instance !== undefined && instance !== null) {\n        if (Array.isArray(instance)) {\n            if (!definition.multiple) {\n                throw new errors.TypeError('Field ' + definition.name + ' does not support multiple values, got ' + JSON.stringify(instance));\n            }\n            var constructor = get_constructor(definition.type);\n            return types.wrap_array(instance, constructor.typecode, constructor.descriptor);\n        } else if (definition.type === '*') {\n            return instance;\n        } else {\n            var wrapper = types['wrap_' + definition.type];\n            if (wrapper) {\n                return wrapper(instance);\n            } else {\n                throw new errors.TypeError('No wrapper for field ' + definition.name + ' of type ' + definition.type);\n            }\n        }\n    } else if (definition.mandatory) {\n        throw new errors.TypeError('Field ' + definition.name + ' is mandatory');\n    } else {\n        return types.Null();\n    }\n}\n\nfunction get_accessors(index, field_definition) {\n    var getter;\n    if (field_definition.type === '*') {\n        getter = function() { return this.value[index]; };\n    } else {\n        getter = function() { return types.unwrap(this.value[index]); };\n    }\n    var setter = function(o) { this.value[index] = wrap_field(field_definition, o); };\n    return {'get': getter, 'set': setter, 'enumerable':true, 'configurable':false};\n}\n\ntypes.define_composite = function(def) {\n    var c = function(fields) {\n        this.value = fields ? fields : [];\n    };\n    c.descriptor = {\n        numeric: def.code,\n        symbolic: 'amqp:' + def.name + ':list'\n    };\n    c.prototype.dispatch = function (target, frame) {\n        target['on_' + def.name](frame);\n    };\n    //c.prototype.descriptor = c.descriptor.numeric;\n    //c.prototype = Object.create(types.List8.prototype);\n    for (var i = 0; i < def.fields.length; i++) {\n        var f = def.fields[i];\n        Object.defineProperty(c.prototype, f.name, get_accessors(i, f));\n    }\n    c.toString = function() {\n        return def.name + '#' + Number(def.code).toString(16);\n    };\n    c.prototype.toJSON = function() {\n        var o = {};\n        for (var f in this) {\n            if (f !== 'value' && this[f]) {\n                o[f] = this[f];\n            }\n        }\n        return o;\n    };\n    c.create = function(fields) {\n        var o = new c;\n        for (var f in fields) {\n            o[f] = fields[f];\n        }\n        return o;\n    };\n    c.prototype.described = function() {\n        return types.described_nc(types.wrap_ulong(c.descriptor.numeric), types.wrap_list(this.value));\n    };\n    return c;\n};\n\nfunction add_type(def) {\n    var c = types.define_composite(def);\n    types['wrap_' + def.name] = function (fields) {\n        return c.create(fields).described();\n    };\n    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;\n    by_descriptor[c.descriptor.symbolic] = c;\n}\n\nadd_type({\n    name: 'error',\n    code: 0x1d,\n    fields: [\n        {name:'condition', type:'symbol', mandatory:true},\n        {name:'description', type:'string'},\n        {name:'info', type:'map'}\n    ]\n});\n\nmodule.exports = types;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar debug = require('debug');\n\nif (debug.formatters) {\n    debug.formatters.h = function (v) {\n        return v.toString('hex');\n    };\n}\n\nmodule.exports = {\n    'config' : debug('rhea:config'),\n    'frames' : debug('rhea:frames'),\n    'raw' : debug('rhea:raw'),\n    'reconnect' : debug('rhea:reconnect'),\n    'events' : debug('rhea:events'),\n    'message' : debug('rhea:message'),\n    'flow' : debug('rhea:flow'),\n    'io' : debug('rhea:io')\n};\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar errors = require('./errors.js');\nvar frames = require('./frames.js');\nvar Transport = require('./transport.js');\nvar util = require('./util.js');\n\nvar sasl_codes = {\n    'OK':0,\n    'AUTH':1,\n    'SYS':2,\n    'SYS_PERM':3,\n    'SYS_TEMP':4,\n};\n\nvar SASL_PROTOCOL_ID = 0x03;\n\nfunction extract(buffer) {\n    var results = [];\n    var start = 0;\n    var i = 0;\n    while (i < buffer.length) {\n        if (buffer[i] === 0x00) {\n            if (i > start) results.push(buffer.toString('utf8', start, i));\n            else results.push(null);\n            start = ++i;\n        } else {\n            ++i;\n        }\n    }\n    if (i > start) results.push(buffer.toString('utf8', start, i));\n    else results.push(null);\n    return results;\n}\n\nvar PlainServer = function(callback) {\n    this.callback = callback;\n    this.outcome = undefined;\n    this.username = undefined;\n};\n\nPlainServer.prototype.start = function(response, hostname) {\n    var fields = extract(response);\n    if (fields.length !== 3) {\n        return Promise.reject('Unexpected response in PLAIN, got ' + fields.length + ' fields, expected 3');\n    }\n    var self = this;\n    return Promise.resolve(this.callback(fields[1], fields[2], hostname))\n        .then(function (result) {\n            if (result) {\n                self.outcome = true;\n                self.username = fields[1];\n            } else {\n                self.outcome = false;\n            }\n        });\n};\n\nvar PlainClient = function(username, password) {\n    this.username = username;\n    this.password = password;\n};\n\nPlainClient.prototype.start = function(callback) {\n    var response = util.allocate_buffer(1 + this.username.length + 1 + this.password.length);\n    response.writeUInt8(0, 0);\n    response.write(this.username, 1);\n    response.writeUInt8(0, 1 + this.username.length);\n    response.write(this.password, 1 + this.username.length + 1);\n    callback(undefined, response);\n};\n\nvar AnonymousServer = function() {\n    this.outcome = undefined;\n    this.username = undefined;\n};\n\nAnonymousServer.prototype.start = function(response) {\n    this.outcome = true;\n    this.username = response ? response.toString('utf8') : 'anonymous';\n};\n\nvar AnonymousClient = function(name) {\n    this.username = name ? name : 'anonymous';\n};\n\nAnonymousClient.prototype.start = function(callback) {\n    var response = util.allocate_buffer(1 + this.username.length);\n    response.writeUInt8(0, 0);\n    response.write(this.username, 1);\n    callback(undefined, response);\n};\n\nvar ExternalServer = function() {\n    this.outcome = undefined;\n    this.username = undefined;\n};\n\nExternalServer.prototype.start = function() {\n    this.outcome = true;\n};\n\nvar ExternalClient = function() {\n    this.username = undefined;\n};\n\nExternalClient.prototype.start = function(callback) {\n    callback(undefined, '');\n};\n\nExternalClient.prototype.step = function(callback) {\n    callback(undefined, '');\n};\n\nvar XOAuth2Client = function(username, token) {\n    this.username = username;\n    this.token = token;\n};\n\nXOAuth2Client.prototype.start = function(callback) {\n    var response = util.allocate_buffer(this.username.length + this.token.length + 5 + 12 + 3);\n    var count = 0;\n    response.write('user=', count);\n    count += 5;\n    response.write(this.username, count);\n    count += this.username.length;\n    response.writeUInt8(1, count);\n    count += 1;\n    response.write('auth=Bearer ', count);\n    count += 12;\n    response.write(this.token, count);\n    count += this.token.length;\n    response.writeUInt8(1, count);\n    count += 1;\n    response.writeUInt8(1, count);\n    count += 1;\n    callback(undefined, response);\n};\n\n/**\n * The mechanisms argument is a map of mechanism names to factory\n * functions for objects that implement that mechanism.\n */\nvar SaslServer = function (connection, mechanisms) {\n    this.connection = connection;\n    this.transport = new Transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames.TYPE_SASL, this);\n    this.next = connection.amqp_transport;\n    this.mechanisms = mechanisms;\n    this.mechanism = undefined;\n    this.outcome = undefined;\n    this.username = undefined;\n    var mechlist = Object.getOwnPropertyNames(mechanisms);\n    this.transport.encode(frames.sasl_frame(frames.sasl_mechanisms({sasl_server_mechanisms:mechlist})));\n};\n\nSaslServer.prototype.do_step = function (challenge) {\n    if (this.mechanism.outcome === undefined) {\n        this.transport.encode(frames.sasl_frame(frames.sasl_challenge({'challenge':challenge})));\n        this.connection.output();\n    } else {\n        this.outcome = this.mechanism.outcome ? sasl_codes.OK : sasl_codes.AUTH;\n        var frame = frames.sasl_frame(frames.sasl_outcome({code: this.outcome}));\n        this.transport.encode(frame);\n        this.connection.output();\n        if (this.outcome === sasl_codes.OK) {\n            this.username = this.mechanism.username;\n            this.transport.write_complete = true;\n            this.transport.read_complete = true;\n        }\n    }\n};\n\nSaslServer.prototype.on_sasl_init = function (frame) {\n    var saslctor = this.mechanisms[frame.performative.mechanism];\n    if (saslctor) {\n        this.mechanism = saslctor();\n        Promise.resolve(this.mechanism.start(frame.performative.initial_response, frame.performative.hostname))\n            .then(this.do_step.bind(this))\n            .catch(this.do_fail.bind(this));\n    } else {\n        this.outcome = sasl_codes.AUTH;\n        this.transport.encode(frames.sasl_frame(frames.sasl_outcome({code: this.outcome})));\n    }\n};\n\nSaslServer.prototype.on_sasl_response = function (frame) {\n    Promise.resolve(this.mechanism.step(frame.performative.response))\n        .then(this.do_step.bind(this))\n        .catch(this.do_fail.bind(this));\n};\n\nSaslServer.prototype.do_fail = function (e) {\n    var frame = frames.sasl_frame(frames.sasl_outcome({code: sasl_codes.SYS}));\n    this.transport.encode(frame);\n    this.connection.output();\n    try {\n        this.connection.sasl_failed('Sasl callback promise failed with ' + e, 'amqp:internal-error');\n    } catch (e) {\n        console.error('Uncaught error: ', e.message);\n    }\n};\n\nSaslServer.prototype.has_writes_pending = function () {\n    return this.transport.has_writes_pending() || this.next.has_writes_pending();\n};\n\nSaslServer.prototype.write = function (socket) {\n    if (this.transport.write_complete && this.transport.pending.length === 0) {\n        return this.next.write(socket);\n    } else {\n        return this.transport.write(socket);\n    }\n};\n\nSaslServer.prototype.peek_size = function (buffer) {\n    if (this.transport.read_complete) {\n        return this.next.peek_size(buffer);\n    } else {\n        return this.transport.peek_size(buffer);\n    }\n};\n\nSaslServer.prototype.read = function (buffer) {\n    if (this.transport.read_complete) {\n        return this.next.read(buffer);\n    } else {\n        return this.transport.read(buffer);\n    }\n};\n\nvar SaslClient = function (connection, mechanisms, hostname) {\n    this.connection = connection;\n    this.transport = new Transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames.TYPE_SASL, this);\n    this.next = connection.amqp_transport;\n    this.mechanisms = mechanisms;\n    this.mechanism = undefined;\n    this.mechanism_name = undefined;\n    this.hostname = hostname;\n    this.failed = false;\n};\n\nSaslClient.prototype.on_sasl_mechanisms = function (frame) {\n    var offered_mechanisms = [];\n    if (Array.isArray(frame.performative.sasl_server_mechanisms)) {\n        offered_mechanisms = frame.performative.sasl_server_mechanisms;\n    } else if (frame.performative.sasl_server_mechanisms) {\n        offered_mechanisms = [frame.performative.sasl_server_mechanisms];\n    }\n    for (var i = 0; this.mechanism === undefined && i < offered_mechanisms.length; i++) {\n        var mech = offered_mechanisms[i];\n        var f = this.mechanisms[mech];\n        if (f) {\n            this.mechanism = typeof f === 'function' ? f() : f;\n            this.mechanism_name = mech;\n        }\n    }\n    if (this.mechanism) {\n        var self = this;\n        this.mechanism.start(function (err, response) {\n            if (err) {\n                self.failed = true;\n                self.connection.sasl_failed('SASL mechanism init failed: ' + err);\n            } else {\n                var init = {'mechanism':self.mechanism_name,'initial_response':response};\n                if (self.hostname) {\n                    init.hostname = self.hostname;\n                }\n                self.transport.encode(frames.sasl_frame(frames.sasl_init(init)));\n                self.connection.output();\n            }\n        });\n    } else {\n        this.failed = true;\n        this.connection.sasl_failed('No suitable mechanism; server supports ' + frame.performative.sasl_server_mechanisms);\n    }\n};\nSaslClient.prototype.on_sasl_challenge = function (frame) {\n    var self = this;\n    this.mechanism.step(frame.performative.challenge, function (err, response) {\n        if (err) {\n            self.failed = true;\n            self.connection.sasl_failed('SASL mechanism challenge failed: ' + err);\n        } else {\n            self.transport.encode(frames.sasl_frame(frames.sasl_response({'response':response})));\n            self.connection.output();\n        }\n    });\n};\nSaslClient.prototype.on_sasl_outcome = function (frame) {\n    switch (frame.performative.code) {\n    case sasl_codes.OK:\n        this.transport.read_complete = true;\n        this.transport.write_complete = true;\n        break;\n    case sasl_codes.SYS:\n    case sasl_codes.SYS_PERM:\n    case sasl_codes.SYS_TEMP:\n        this.transport.write_complete = true;\n        this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code, 'amqp:internal-error');\n        break;\n    default:\n        this.transport.write_complete = true;\n        this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code);\n    }\n};\n\nSaslClient.prototype.has_writes_pending = function () {\n    return this.transport.has_writes_pending() || this.next.has_writes_pending();\n};\n\nSaslClient.prototype.write = function (socket) {\n    if (this.transport.write_complete) {\n        return this.next.write(socket);\n    } else {\n        return this.transport.write(socket);\n    }\n};\n\nSaslClient.prototype.peek_size = function (buffer) {\n    if (this.transport.read_complete) {\n        return this.next.peek_size(buffer);\n    } else {\n        return this.transport.peek_size(buffer);\n    }\n};\n\nSaslClient.prototype.read = function (buffer) {\n    if (this.transport.read_complete) {\n        return this.next.read(buffer);\n    } else {\n        return this.transport.read(buffer);\n    }\n};\n\nvar SelectiveServer = function (connection, mechanisms) {\n    this.header_received = false;\n    this.transports = {\n        0: connection.amqp_transport,\n        3: new SaslServer(connection, mechanisms)\n    };\n    this.selected = undefined;\n};\n\nSelectiveServer.prototype.has_writes_pending = function () {\n    return this.header_received && this.selected.has_writes_pending();\n};\n\nSelectiveServer.prototype.write = function (socket) {\n    if (this.selected) {\n        return this.selected.write(socket);\n    } else {\n        return 0;\n    }\n};\n\nSelectiveServer.prototype.peek_size = function (buffer) {\n    if (this.header_received) {\n        return this.selected.peek_size(buffer);\n    }\n    return undefined;\n};\n\nSelectiveServer.prototype.read = function (buffer) {\n    if (!this.header_received) {\n        if (buffer.length < 8) {\n            return 0;\n        } else {\n            this.header_received = frames.read_header(buffer);\n            this.selected = this.transports[this.header_received.protocol_id];\n            if (this.selected === undefined) {\n                throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id);\n            }\n        }\n    }\n    return this.selected.read(buffer);\n};\n\nvar default_server_mechanisms = {\n    enable_anonymous: function () {\n        this['ANONYMOUS'] = function() { return new AnonymousServer(); };\n    },\n    enable_plain: function (callback) {\n        this['PLAIN'] = function() { return new PlainServer(callback); };\n    }\n};\n\nvar default_client_mechanisms = {\n    enable_anonymous: function (name) {\n        this['ANONYMOUS'] = function() { return new AnonymousClient(name); };\n    },\n    enable_plain: function (username, password) {\n        this['PLAIN'] = function() { return new PlainClient(username, password); };\n    },\n    enable_external: function () {\n        this['EXTERNAL'] = function() { return new ExternalClient(); };\n    },\n    enable_xoauth2: function (username, token) {\n        if (username && token) {\n            this['XOAUTH2'] = function() { return new XOAuth2Client(username, token); };\n        } else if (token === undefined) {\n            throw Error('token must be specified');\n        } else if (username === undefined) {\n            throw Error('username must be specified');\n        }\n    }\n};\n\nmodule.exports = {\n    Client : SaslClient,\n    Server : SaslServer,\n    Selective: SelectiveServer,\n    server_mechanisms : function () {\n        return Object.create(default_server_mechanisms);\n    },\n    client_mechanisms : function () {\n        return Object.create(default_client_mechanisms);\n    },\n    server_add_external: function (mechs) {\n        mechs['EXTERNAL'] = function() { return new ExternalServer(); };\n        return mechs;\n    }\n};\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar errors = require('./errors.js');\nvar frames = require('./frames.js');\nvar log = require('./log.js');\nvar util = require('./util.js');\n\n\nvar Transport = function (identifier, protocol_id, frame_type, handler) {\n    this.identifier = identifier;\n    this.protocol_id = protocol_id;\n    this.frame_type = frame_type;\n    this.handler = handler;\n    this.pending = [];\n    this.header_sent = undefined;\n    this.header_received = undefined;\n    this.write_complete = false;\n    this.read_complete = false;\n};\n\nTransport.prototype.has_writes_pending = function () {\n    return this.pending.length > 0 || !this.header_sent;\n};\n\nTransport.prototype.encode = function (frame) {\n    this.pending.push(frame);\n};\n\nTransport.prototype.write = function (socket) {\n    if (!this.header_sent) {\n        var buffer = util.allocate_buffer(8);\n        var header = {protocol_id:this.protocol_id, major:1, minor:0, revision:0};\n        log.frames('[%s] -> %o', this.identifier, header);\n        frames.write_header(buffer, header);\n        socket.write(buffer);\n        this.header_sent = header;\n    }\n    for (var i = 0; i < this.pending.length; i++) {\n        var frame = this.pending[i];\n        var buffer = frames.write_frame(frame);\n        socket.write(buffer);\n        if (frame.performative) {\n            log.frames('[%s]:%s -> %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');\n        } else {\n            log.frames('[%s]:%s -> empty', this.identifier, frame.channel);\n        }\n        log.raw('[%s] SENT: %d %h', this.identifier, buffer.length, buffer);\n    }\n    this.pending = [];\n};\n\nTransport.prototype.peek_size = function (buffer) {\n    log.frames('[%s] peek_size %o, %d', this.identifier, this.header_received, buffer.length);\n    if (this.header_received && buffer.length >= 4) {\n        return buffer.readUInt32BE();\n    }\n    return undefined;\n};\n\nTransport.prototype.read = function (buffer) {\n    var offset = 0;\n    if (!this.header_received) {\n        if (buffer.length < 8) {\n            return offset;\n        } else {\n            this.header_received = frames.read_header(buffer);\n            log.frames('[%s] <- %o', this.identifier, this.header_received);\n            if (this.header_received.protocol_id !== this.protocol_id) {\n                if (this.protocol_id === 3 && this.header_received.protocol_id === 0) {\n                    throw new errors.ProtocolError('Expecting SASL layer');\n                } else if (this.protocol_id === 0 && this.header_received.protocol_id === 3) {\n                    throw new errors.ProtocolError('SASL layer not enabled');\n                } else {\n                    throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id + ' expecting: ' + this.protocol_id);\n                }\n            }\n            offset = 8;\n        }\n    }\n    while (offset < (buffer.length - 4) && !this.read_complete) {\n        var frame_size = buffer.readUInt32BE(offset);\n        log.io('[%s] got frame of size %d', this.identifier, frame_size);\n        if (buffer.length < offset + frame_size) {\n            log.io('[%s] incomplete frame; have only %d of %d', this.identifier, (buffer.length - offset), frame_size);\n            //don't have enough data for a full frame yet\n            break;\n        } else {\n            var slice = buffer.slice(offset, offset + frame_size);\n            log.raw('[%s] RECV: %d %h', this.identifier, slice.length, slice);\n            var frame = frames.read_frame(slice);\n            if (frame.performative) {\n                log.frames('[%s]:%s <- %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');\n            } else {\n                log.frames('[%s]:%s <- empty', this.identifier, frame.channel);\n\n            }\n            if (frame.type !== this.frame_type) {\n                throw new errors.ProtocolError('Invalid frame type: ' + frame.type);\n            }\n            offset += frame_size;\n            if (frame.performative) {\n                frame.performative.dispatch(this.handler, frame);\n            }\n        }\n    }\n    return offset;\n};\n\nmodule.exports = Transport;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar EndpointState = function () {\n    this.init();\n};\n\nEndpointState.prototype.init = function () {\n    this.local_open = false;\n    this.remote_open = false;\n    this.open_requests = 0;\n    this.close_requests = 0;\n    this.initialised = false;\n    this.marker = undefined;\n};\n\nEndpointState.prototype.mark = function (o) {\n    this.marker = o || Date.now();\n    return this.marker;\n};\n\nEndpointState.prototype.open = function () {\n    this.marker = undefined;\n    this.initialised = true;\n    if (!this.local_open) {\n        this.local_open = true;\n        this.open_requests++;\n        return true;\n    } else {\n        return false;\n    }\n};\n\nEndpointState.prototype.close = function () {\n    this.marker = undefined;\n    if (this.local_open) {\n        this.local_open = false;\n        this.close_requests++;\n        return true;\n    } else {\n        return false;\n    }\n};\n\nEndpointState.prototype.disconnected = function () {\n    var was_initialised = this.initialised;\n    this.was_open = this.local_open;\n    this.init();\n    this.initialised = was_initialised;\n};\n\nEndpointState.prototype.reconnect = function () {\n    if (this.was_open) {\n        this.open();\n        this.was_open = undefined;\n    }\n};\n\nEndpointState.prototype.remote_opened = function () {\n    if (!this.remote_open) {\n        this.remote_open = true;\n        return true;\n    } else {\n        return false;\n    }\n};\n\nEndpointState.prototype.remote_closed = function () {\n    if (this.remote_open) {\n        this.remote_open = false;\n        return true;\n    } else {\n        return false;\n    }\n};\n\nEndpointState.prototype.is_open = function () {\n    return this.local_open && this.remote_open;\n};\n\nEndpointState.prototype.is_closed = function () {\n    return this.initialised && !(this.local_open || this.was_open) && !this.remote_open;\n};\n\nEndpointState.prototype.has_settled = function () {\n    return this.open_requests === 0 && this.close_requests === 0;\n};\n\nEndpointState.prototype.need_open = function () {\n    if (this.open_requests > 0) {\n        this.open_requests--;\n        return true;\n    } else {\n        return false;\n    }\n};\n\nEndpointState.prototype.need_close = function () {\n    if (this.close_requests > 0) {\n        this.close_requests--;\n        return true;\n    } else {\n        return false;\n    }\n};\n\nmodule.exports = EndpointState;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar frames = require('./frames.js');\nvar link = require('./link.js');\nvar log = require('./log.js');\nvar message = require('./message.js');\nvar types = require('./types.js');\nvar util = require('./util.js');\nvar EndpointState = require('./endpoint.js');\n\nvar EventEmitter = require('events').EventEmitter;\n\nfunction SessionError(message, condition, session) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.condition = condition;\n    this.description = message;\n    Object.defineProperty(this, 'session', { value: session });\n}\nrequire('util').inherits(SessionError, Error);\n\nvar CircularBuffer = function (capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.head = 0;\n    this.tail = 0;\n    this.entries = [];\n};\n\nCircularBuffer.prototype.available = function () {\n    return this.capacity - this.size;\n};\n\nCircularBuffer.prototype.push = function (o) {\n    if (this.size < this.capacity) {\n        this.entries[this.tail] = o;\n        this.tail = (this.tail + 1) % this.capacity;\n        this.size++;\n    } else {\n        throw Error('circular buffer overflow: head=' + this.head + ' tail=' + this.tail + ' size=' + this.size + ' capacity=' + this.capacity);\n    }\n};\n\nCircularBuffer.prototype.pop_if = function (f) {\n    var count = 0;\n    while (this.size && f(this.entries[this.head])) {\n        this.entries[this.head] = undefined;\n        this.head = (this.head + 1) % this.capacity;\n        this.size--;\n        count++;\n    }\n    return count;\n};\n\nCircularBuffer.prototype.by_id = function (id) {\n    if (this.size > 0) {\n        var gap = id - this.entries[this.head].id;\n        if (gap < this.size) {\n            return this.entries[(this.head + gap) % this.capacity];\n        }\n    }\n    return undefined;\n};\n\nCircularBuffer.prototype.get_head = function () {\n    return this.size > 0 ? this.entries[this.head] : undefined;\n};\n\nCircularBuffer.prototype.get_tail = function () {\n    return this.size > 0 ? this.entries[(this.head + this.size - 1) % this.capacity] : undefined;\n};\n\nfunction write_dispositions(deliveries) {\n    var first, last, next_id, i, delivery;\n\n    for (i = 0; i < deliveries.length; i++) {\n        delivery = deliveries[i];\n        if (first === undefined) {\n            first = delivery;\n            last = delivery;\n            next_id = delivery.id;\n        }\n\n        if ((first !== last && !message.are_outcomes_equivalent(last.state, delivery.state)) || last.settled !== delivery.settled || next_id !== delivery.id) {\n            first.link.session.output(frames.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));\n            first = delivery;\n            last = delivery;\n            next_id = delivery.id;\n        } else {\n            if (last.id !== delivery.id) {\n                last = delivery;\n            }\n            next_id++;\n        }\n    }\n    if (first !== undefined && last !== undefined) {\n        first.link.session.output(frames.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));\n    }\n}\n\nvar Outgoing = function (connection) {\n    /* TODO: make size configurable? */\n    this.deliveries = new CircularBuffer(2048);\n    this.updated = [];\n    this.pending_dispositions = [];\n    this.next_delivery_id = 0;\n    this.next_pending_delivery = 0;\n    this.next_transfer_id = 0;\n    this.window = types.MAX_UINT;\n    this.remote_next_transfer_id = undefined;\n    this.remote_window = undefined;\n    this.connection = connection;\n};\n\nOutgoing.prototype.available = function () {\n    return this.deliveries.available();\n};\n\nOutgoing.prototype.compute_max_payload = function (tag) {\n    if (this.connection.max_frame_size) {\n        return this.connection.max_frame_size - (50 + tag.length);\n    } else {\n        return undefined;\n    }\n};\n\nOutgoing.prototype.send = function (sender, tag, data, format) {\n    var fragments = [];\n    var max_payload = this.compute_max_payload(tag);\n    if (max_payload && data.length > max_payload) {\n        var start = 0;\n        while (start < data.length) {\n            var end = Math.min(start + max_payload, data.length);\n            fragments.push(data.slice(start, end));\n            start = end;\n        }\n    } else {\n        fragments.push(data);\n    }\n    var d = {\n        'id':this.next_delivery_id++,\n        'tag':tag,\n        'link':sender,\n        'data': fragments,\n        'format':format ? format : 0,\n        'next_to_send': 0,\n        'sent': false,\n        'settled': false,\n        'state': undefined,\n        'remote_settled': false,\n        'remote_state': undefined\n    };\n    var self = this;\n    d.update = function (settled, state) {\n        self.update(d, settled, state);\n    };\n    this.deliveries.push(d);\n    return d;\n};\n\nOutgoing.prototype.on_begin = function (fields) {\n    this.remote_window = fields.incoming_window;\n};\n\nOutgoing.prototype.on_flow = function (fields) {\n    this.remote_next_transfer_id = fields.next_incoming_id;\n    this.remote_window = fields.incoming_window;\n};\n\nOutgoing.prototype.on_disposition = function (fields) {\n    var last = fields.last ? fields.last : fields.first;\n    for (var i = fields.first; i <= last; i++) {\n        var d = this.deliveries.by_id(i);\n        if (d && !d.remote_settled) {\n            var updated = false;\n            if (fields.settled) {\n                d.remote_settled = fields.settled;\n                updated = true;\n            }\n            if (fields.state && fields.state !== d.remote_state) {\n                d.remote_state = message.unwrap_outcome(fields.state);\n                updated = true;\n            }\n            if (updated) {\n                this.updated.push(d);\n            }\n        }\n    }\n};\n\nOutgoing.prototype.update = function (delivery, settled, state) {\n    if (delivery) {\n        delivery.settled = settled;\n        if (state !== undefined) delivery.state = state;\n        if (!delivery.remote_settled) {\n            this.pending_dispositions.push(delivery);\n        }\n        delivery.link.connection._register();\n    }\n};\n\nOutgoing.prototype.transfer_window = function() {\n    if (this.remote_window) {\n        return this.remote_window - (this.next_transfer_id - this.remote_next_transfer_id);\n    } else {\n        return 0;\n    }\n};\n\nOutgoing.prototype.process = function() {\n    var d;\n    // send pending deliveries for which there is credit:\n    while (this.next_pending_delivery < this.next_delivery_id) {\n        d = this.deliveries.by_id(this.next_pending_delivery);\n        if (d) {\n            if (d.link.has_credit()) {\n                const num_to_send = Math.min(this.transfer_window(), d.data.length - d.next_to_send);\n                if (num_to_send > 0) {\n                    this.window -= num_to_send;\n                    const end_of_send = d.next_to_send + num_to_send;\n                    for (var i = d.next_to_send; i < end_of_send; i++) {\n                        this.next_transfer_id++;\n                        var more = (i+1) < d.data.length;\n                        var transfer = frames.transfer({'handle':d.link.local.handle,'message_format':d.format,'delivery_id':d.id, 'delivery_tag':d.tag, 'settled':d.settled, 'more':more});\n                        d.link.session.output(transfer, d.data[i]);\n                    }\n                    if (end_of_send < d.data.length) {\n                        d.next_to_send = end_of_send;\n                        break;\n                    } else {\n                        if (d.settled) {\n                            d.remote_settled = true;//if sending presettled, it can now be cleaned up\n                        }\n                        d.link.credit--;\n                        d.link.delivery_count++;\n                        this.next_pending_delivery++;\n                    }\n                } else {\n                    log.flow('[%s] Incoming window of peer preventing sending further transfers: remote_window=%d, remote_next_transfer_id=%d, next_transfer_id=%d',\n                        this.connection.options.id, this.remote_window, this.remote_next_transfer_id, this.next_transfer_id);\n                    break;\n                }\n            } else {\n                log.flow('[%s] Link has no credit', this.connection.options.id);\n                break;\n            }\n        } else {\n            console.error('ERROR: Next pending delivery not found: ' + this.next_pending_delivery);\n            break;\n        }\n    }\n\n    // notify application of any updated deliveries:\n    for (var i = 0; i < this.updated.length; i++) {\n        d = this.updated[i];\n        if (d.remote_state && d.remote_state.constructor.composite_type) {\n            d.link.dispatch(d.remote_state.constructor.composite_type, d.link._context({'delivery':d}));\n        }\n        if (d.remote_settled) d.link.dispatch('settled', d.link._context({'delivery':d}));\n    }\n    this.updated = [];\n\n    if (this.pending_dispositions.length) {\n        write_dispositions(this.pending_dispositions);\n        this.pending_dispositions = [];\n    }\n\n    // remove any fully settled deliveries:\n    this.deliveries.pop_if(function (d) { return d.settled && d.remote_settled; });\n};\n\nvar Incoming = function () {\n    this.deliveries = new CircularBuffer(2048/*TODO: configurable?*/);\n    this.updated = [];\n    this.next_transfer_id = 0;\n    this.next_delivery_id = undefined;\n    Object.defineProperty(this, 'window', { get: function () { return this.deliveries.available(); } });\n    this.remote_next_transfer_id = undefined;\n    this.remote_window = undefined;\n    this.max_transfer_id = this.next_transfer_id + this.window;\n};\n\nIncoming.prototype.update = function (delivery, settled, state) {\n    if (delivery) {\n        delivery.settled = settled;\n        if (state !== undefined) delivery.state = state;\n        if (!delivery.remote_settled) {\n            this.updated.push(delivery);\n        }\n        delivery.link.connection._register();\n    }\n};\n\nIncoming.prototype.on_transfer = function(frame, receiver) {\n    this.next_transfer_id++;\n    if (receiver.is_remote_open()) {\n        if (this.next_delivery_id === undefined) {\n            this.next_delivery_id = frame.performative.delivery_id;\n        }\n        var current;\n        if (receiver._incomplete) {\n            current = receiver._incomplete;\n            if (util.is_defined(frame.performative.delivery_id) && current.id !== frame.performative.delivery_id) {\n                throw Error('frame sequence error: delivery ' + current.id + ' not complete, got ' + frame.performative.delivery_id);\n            }\n            if (frame.payload) {\n                current.frames.push(frame.payload);\n            }\n        } else if (this.next_delivery_id === frame.performative.delivery_id) {\n            current = {'id':frame.performative.delivery_id,\n                'tag':frame.performative.delivery_tag,\n                'format':frame.performative.message_format,\n                'link':receiver,\n                'settled': false,\n                'state': undefined,\n                'remote_settled': frame.performative.settled === undefined ? false : frame.performative.settled,\n                'remote_state': frame.performative.state,\n                'frames': [frame.payload],\n            };\n            var self = this;\n            current.update = function (settled, state) {\n                var settled_ = settled;\n                if (settled_ === undefined) {\n                    settled_ = receiver.local.attach.rcv_settle_mode !== 1;\n                }\n                self.update(current, settled_, state);\n            };\n            current.accept = function () { this.update(undefined, message.accepted().described()); };\n            current.release = function (params) {\n                if (params) {\n                    this.update(undefined, message.modified(params).described());\n                } else {\n                    this.update(undefined, message.released().described());\n                }\n            };\n            current.reject = function (error) { this.update(undefined, message.rejected({'error':error}).described()); };\n            current.modified = function (params) { this.update(undefined, message.modified(params).described()); };\n\n            this.deliveries.push(current);\n            this.next_delivery_id++;\n        } else {\n            //TODO: better error handling\n            throw Error('frame sequence error: expected ' + this.next_delivery_id + ', got ' + frame.performative.delivery_id);\n        }\n        current.incomplete = frame.performative.more;\n        if (current.incomplete) {\n            receiver._incomplete = current;\n        } else {\n            receiver._incomplete = undefined;\n            const data = current.frames.length === 1 ? current.frames[0] : Buffer.concat(current.frames);\n            delete current.frames;\n            if (receiver.credit > 0) receiver.credit--;\n            else console.error('Received transfer when credit was %d', receiver.credit);\n            receiver.delivery_count++;\n            var msgctxt = current.format === 0 ? {'message':message.decode(data), 'delivery':current} : {'message':data, 'delivery':current, 'format':current.format};\n            receiver.dispatch('message', receiver._context(msgctxt));\n        }\n    } else {\n        throw Error('transfer after detach');\n    }\n};\n\nIncoming.prototype.process = function (session) {\n    if (this.updated.length > 0) {\n        write_dispositions(this.updated);\n        this.updated = [];\n    }\n\n    // remove any fully settled deliveries:\n    this.deliveries.pop_if(function (d) { return d.settled; });\n\n    if (this.max_transfer_id - this.next_transfer_id < (this.window / 2)) {\n        session._write_flow();\n    }\n};\n\nIncoming.prototype.on_begin = function (fields) {\n    this.remote_window = fields.outgoing_window;\n    this.remote_next_transfer_id = fields.next_outgoing_id;\n};\n\nIncoming.prototype.on_flow = function (fields) {\n    this.remote_next_transfer_id = fields.next_outgoing_id;\n    this.remote_window = fields.outgoing_window;\n};\n\nIncoming.prototype.on_disposition = function (fields) {\n    var last = fields.last ? fields.last : fields.first;\n    for (var i = fields.first; i <= last; i++) {\n        var d = this.deliveries.by_id(i);\n        if (d && !d.remote_settled) {\n            if (fields.state && fields.state !== d.remote_state) {\n                d.remote_state = message.unwrap_outcome(fields.state);\n            }\n            if (fields.settled) {\n                d.remote_settled = fields.settled;\n                d.link.dispatch('settled', d.link._context({'delivery':d}));\n            }\n        }\n    }\n};\n\nvar Session = function (connection, local_channel) {\n    this.connection = connection;\n    this.outgoing = new Outgoing(connection);\n    this.incoming = new Incoming();\n    this.state = new EndpointState();\n    this.local = {'channel': local_channel, 'handles':{}};\n    this.local.begin = frames.begin({next_outgoing_id:this.outgoing.next_transfer_id,incoming_window:this.incoming.window,outgoing_window:this.outgoing.window});\n    this.local.end = frames.end();\n    this.remote = {'handles':{}};\n    this.links = {}; // map by name\n    this.options = {};\n    Object.defineProperty(this, 'error', { get:  function() { return this.remote.end ? this.remote.end.error : undefined; }});\n    this.observers = new EventEmitter();\n};\nSession.prototype = Object.create(EventEmitter.prototype);\nSession.prototype.constructor = Session;\n\nSession.prototype._disconnect = function() {\n    this.state.disconnected();\n    for (var l in this.links) {\n        this.links[l]._disconnect();\n    }\n    if (!this.state.was_open) {\n        this.remove();\n    }\n};\n\nSession.prototype._reconnect = function() {\n    this.state.reconnect();\n    this.outgoing = new Outgoing(this.connection);\n    this.incoming = new Incoming();\n    this.remote = {'handles':{}};\n    for (var l in this.links) {\n        this.links[l]._reconnect();\n    }\n};\n\nSession.prototype.dispatch = function(name) {\n    log.events('[%s] Session got event: %s', this.connection.options.id, name);\n    EventEmitter.prototype.emit.apply(this.observers, arguments);\n    if (this.listeners(name).length) {\n        EventEmitter.prototype.emit.apply(this, arguments);\n        return true;\n    } else {\n        return this.connection.dispatch.apply(this.connection, arguments);\n    }\n};\nSession.prototype.output = function (frame, payload) {\n    this.connection._write_frame(this.local.channel, frame, payload);\n};\n\nSession.prototype.create_sender = function (name, opts) {\n    if (!opts) {\n        opts = this.get_option('sender_options', {});\n    }\n    return this.create_link(name, link.Sender, opts);\n};\n\nSession.prototype.create_receiver = function (name, opts) {\n    if (!opts) {\n        opts = this.get_option('receiver_options', {});\n    }\n    return this.create_link(name, link.Receiver, opts);\n};\n\nfunction merge(defaults, specific) {\n    for (var f in specific) {\n        if (f === 'properties' && defaults.properties) {\n            merge(defaults.properties, specific.properties);\n        } else {\n            defaults[f] = specific[f];\n        }\n    }\n}\n\nfunction attach(factory, args, remote_terminus, default_args) {\n    var opts = Object.create(default_args || {});\n    if (typeof args === 'string') {\n        opts[remote_terminus] = args;\n    } else if (args) {\n        merge(opts, args);\n    }\n    if (!opts.name) opts.name = util.generate_uuid();\n    var l = factory(opts.name, opts);\n    for (var t in {'source':0, 'target':0}) {\n        if (opts[t]) {\n            if (typeof opts[t] === 'string') {\n                opts[t] = {'address' : opts[t]};\n            }\n            l['set_' + t](opts[t]);\n        }\n    }\n    if (l.is_sender() && opts.source === undefined) {\n        opts.source = l.set_source({});\n    }\n    if (l.is_receiver() && opts.target === undefined) {\n        opts.target = l.set_target({});\n    }\n    l.attach();\n    return l;\n}\n\nSession.prototype.get_option = function (name, default_value) {\n    if (this.options[name] !== undefined) return this.options[name];\n    else return this.connection.get_option(name, default_value);\n};\n\nSession.prototype.attach_sender = function (args) {\n    return attach(this.create_sender.bind(this), args, 'target', this.get_option('sender_options', {}));\n};\nSession.prototype.open_sender = Session.prototype.attach_sender;//alias\n\nSession.prototype.attach_receiver = function (args) {\n    return attach(this.create_receiver.bind(this), args, 'source', this.get_option('receiver_options', {}));\n};\nSession.prototype.open_receiver = Session.prototype.attach_receiver;//alias\n\nSession.prototype.find_sender = function (filter) {\n    return this.find_link(util.sender_filter(filter));\n};\n\nSession.prototype.find_receiver = function (filter) {\n    return this.find_link(util.receiver_filter(filter));\n};\n\nSession.prototype.find_link = function (filter) {\n    for (var name in this.links) {\n        var link = this.links[name];\n        if (filter(link)) return link;\n    }\n    return undefined;\n};\n\nSession.prototype.each_receiver = function (action, filter) {\n    this.each_link(action, util.receiver_filter(filter));\n};\n\nSession.prototype.each_sender = function (action, filter) {\n    this.each_link(action, util.sender_filter(filter));\n};\n\nSession.prototype.each_link = function (action, filter) {\n    for (var name in this.links) {\n        var link = this.links[name];\n        if (filter === undefined || filter(link)) action(link);\n    }\n};\n\nSession.prototype.create_link = function (name, constructor, opts) {\n    var i = 0;\n    while (this.local.handles[i]) i++;\n    var l = new constructor(this, name, i, opts);\n    this.links[name] = l;\n    this.local.handles[i] = l;\n    return l;\n};\n\nSession.prototype.begin = function () {\n    if (this.state.open()) {\n        this.connection._register();\n    }\n};\nSession.prototype.open = Session.prototype.begin;\n\nSession.prototype.end = function (error) {\n    if (error) this.local.end.error = error;\n    if (this.state.close()) {\n        this.connection._register();\n    }\n};\nSession.prototype.close = Session.prototype.end;\n\nSession.prototype.is_open = function () {\n    return this.connection.is_open() && this.state.is_open();\n};\n\nSession.prototype.is_remote_open = function () {\n    return this.connection.is_remote_open() && this.state.remote_open;\n};\n\nSession.prototype.is_itself_closed = function () {\n    return this.state.is_closed();\n};\n\nSession.prototype.is_closed = function () {\n    return this.connection.is_closed() || this.is_itself_closed();\n};\n\nfunction notify_sendable(sender) {\n    sender.dispatch('sendable', sender._context());\n}\n\nfunction is_sender_sendable(sender) {\n    return sender.is_open() && sender.sendable();\n}\n\nSession.prototype._process = function () {\n    do {\n        if (this.state.need_open()) {\n            this.output(this.local.begin);\n        }\n\n        var was_blocked = this.outgoing.deliveries.available() === 0;\n        this.outgoing.process();\n        if (was_blocked && this.outgoing.deliveries.available()) {\n            this.each_sender(notify_sendable, is_sender_sendable);\n        }\n        this.incoming.process(this);\n        for (var k in this.links) {\n            this.links[k]._process();\n        }\n\n        if (this.state.need_close()) {\n            this.output(this.local.end);\n        }\n    } while (!this.state.has_settled());\n};\n\nSession.prototype.send = function (sender, tag, data, format) {\n    var d = this.outgoing.send(sender, tag, data, format);\n    this.connection._register();\n    return d;\n};\n\nSession.prototype._write_flow = function (link) {\n    var fields = {'next_incoming_id':this.incoming.next_transfer_id,\n        'incoming_window':this.incoming.window,\n        'next_outgoing_id':this.outgoing.next_transfer_id,\n        'outgoing_window':this.outgoing.window\n    };\n    this.incoming.max_transfer_id = fields.next_incoming_id + fields.incoming_window;\n    if (link) {\n        if (link._get_drain()) fields.drain = true;\n        fields.delivery_count = link.delivery_count;\n        fields.handle = link.local.handle;\n        fields.link_credit = link.credit;\n    }\n    this.output(frames.flow(fields));\n};\n\nSession.prototype.on_begin = function (frame) {\n    if (this.state.remote_opened()) {\n        if (!this.remote.channel) {\n            this.remote.channel = frame.channel;\n        }\n        this.remote.begin = frame.performative;\n        this.outgoing.on_begin(frame.performative);\n        this.incoming.on_begin(frame.performative);\n        this.open();\n        this.dispatch('session_open', this._context());\n    } else {\n        throw Error('Begin already received');\n    }\n};\nSession.prototype.on_end = function (frame) {\n    if (this.state.remote_closed()) {\n        this.remote.end = frame.performative;\n        var error = this.remote.end.error;\n        if (error) {\n            var handled = this.dispatch('session_error', this._context());\n            handled = this.dispatch('session_close', this._context()) || handled;\n            if (!handled) {\n                EventEmitter.prototype.emit.call(this.connection.container, 'error', new SessionError(error.description, error.condition, this));\n            }\n        } else {\n            this.dispatch('session_close', this._context());\n        }\n        var self = this;\n        var token = this.state.mark();\n        process.nextTick(function () {\n            if (self.state.marker === token) {\n                self.close();\n                process.nextTick(function () { self.remove(); });\n            }\n        });\n    } else {\n        throw Error('End already received');\n    }\n};\n\nSession.prototype.on_attach = function (frame) {\n    var name = frame.performative.name;\n    var link = this.links[name];\n    if (!link) {\n        // if role is true, peer is receiver, so we are sender\n        link = frame.performative.role ? this.create_sender(name) : this.create_receiver(name);\n    }\n    this.remote.handles[frame.performative.handle] = link;\n    link.on_attach(frame);\n    link.remote.attach = frame.performative;\n};\n\nSession.prototype.on_disposition = function (frame) {\n    if (frame.performative.role) {\n        log.events('[%s] Received disposition for outgoing transfers', this.connection.options.id);\n        this.outgoing.on_disposition(frame.performative);\n    } else {\n        log.events('[%s] Received disposition for incoming transfers', this.connection.options.id);\n        this.incoming.on_disposition(frame.performative);\n    }\n    this.connection._register();\n};\n\nSession.prototype.on_flow = function (frame) {\n    this.outgoing.on_flow(frame.performative);\n    this.incoming.on_flow(frame.performative);\n    if (util.is_defined(frame.performative.handle)) {\n        this._get_link(frame).on_flow(frame);\n    }\n    this.connection._register();\n};\n\nSession.prototype._context = function (c) {\n    var context = c ? c : {};\n    context.session = this;\n    return this.connection._context(context);\n};\n\nSession.prototype._get_link = function (frame) {\n    var handle = frame.performative.handle;\n    var link = this.remote.handles[handle];\n    if (!link) {\n        throw Error('Invalid handle ' + handle);\n    }\n    return link;\n};\n\nSession.prototype.on_detach = function (frame) {\n    this._get_link(frame).on_detach(frame);\n};\n\nSession.prototype.remove_link = function (link) {\n    delete this.remote.handles[link.remote.handle];\n    delete this.local.handles[link.local.handle];\n    delete this.links[link.name];\n};\n\n/**\n * This forcibly removes the session from the parent connection. It\n * should not be called for a link on an active connection, where\n * close() should be used instead.\n */\nSession.prototype.remove = function () {\n    this.connection.remove_session(this);\n};\n\nSession.prototype.on_transfer = function (frame) {\n    this.incoming.on_transfer(frame, this._get_link(frame));\n};\n\nmodule.exports = Session;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar frames = require('./frames.js');\nvar log = require('./log.js');\nvar message = require('./message.js');\nvar terminus = require('./terminus.js');\nvar EndpointState = require('./endpoint.js');\n\nvar FlowController = function (window) {\n    this.window = window;\n};\nFlowController.prototype.update = function (context) {\n    var delta = this.window - context.receiver.credit;\n    if (delta >= (this.window/4)) {\n        context.receiver.flow(delta);\n    }\n};\n\nfunction auto_settle(context) {\n    context.delivery.settled = true;\n}\n\nfunction auto_accept(context) {\n    context.delivery.update(undefined, message.accepted().described());\n}\n\nfunction LinkError(message, condition, link) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.condition = condition;\n    this.description = message;\n    Object.defineProperty(this, 'link', { value: link });\n}\nrequire('util').inherits(LinkError, Error);\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar link = Object.create(EventEmitter.prototype);\nlink.dispatch = function(name) {\n    log.events('[%s] Link got event: %s', this.connection.options.id, name);\n    EventEmitter.prototype.emit.apply(this.observers, arguments);\n    if (this.listeners(name).length) {\n        EventEmitter.prototype.emit.apply(this, arguments);\n        return true;\n    } else {\n        return this.session.dispatch.apply(this.session, arguments);\n    }\n};\nlink.set_source = function (fields) {\n    this.local.attach.source = terminus.source(fields).described();\n};\nlink.set_target = function (fields) {\n    this.local.attach.target = terminus.target(fields).described();\n};\n\nlink.attach = function () {\n    if (this.state.open()) {\n        this.connection._register();\n    }\n};\nlink.open = link.attach;\n\nlink.detach = function () {\n    this.local.detach.closed = false;\n    if (this.state.close()) {\n        this.connection._register();\n    }\n};\nlink.close = function(error) {\n    if (error) this.local.detach.error = error;\n    this.local.detach.closed = true;\n    if (this.state.close()) {\n        this.connection._register();\n    }\n};\n\n/**\n * This forcibly removes the link from the parent session. It should\n * not be called for a link on an active session/connection, where\n * close() should be used instead.\n */\nlink.remove = function() {\n    this.session.remove_link(this);\n};\n\nlink.is_open = function () {\n    return this.session.is_open() && this.state.is_open();\n};\n\nlink.is_remote_open = function () {\n    return this.session.is_remote_open() && this.state.remote_open;\n};\n\nlink.is_itself_closed = function() {\n    return this.state.is_closed();\n};\n\nlink.is_closed = function () {\n    return this.session.is_closed() || this.is_itself_closed();\n};\n\nlink._process = function () {\n    do {\n        if (this.state.need_open()) {\n            this.session.output(this.local.attach);\n        }\n\n        if (this.issue_flow && this.state.local_open) {\n            this.session._write_flow(this);\n            this.issue_flow = false;\n        }\n\n        if (this.state.need_close()) {\n            this.session.output(this.local.detach);\n        }\n    } while (!this.state.has_settled());\n};\n\nlink.on_attach = function (frame) {\n    if (this.state.remote_opened()) {\n        if (!this.remote.handle) {\n            this.remote.handle = frame.handle;\n        }\n        frame.performative.source = terminus.unwrap(frame.performative.source);\n        frame.performative.target = terminus.unwrap(frame.performative.target);\n        this.remote.attach = frame.performative;\n        this.open();\n        this.dispatch(this.is_receiver() ? 'receiver_open' : 'sender_open', this._context());\n    } else {\n        throw Error('Attach already received');\n    }\n};\n\nlink.prefix_event = function (event) {\n    return (this.local.attach.role ? 'receiver_' : 'sender_') + event;\n};\n\nlink.on_detach = function (frame) {\n    if (this.state.remote_closed()) {\n        if (this._incomplete) {\n            this._incomplete.settled = true;\n        }\n        this.remote.detach = frame.performative;\n        var error = this.remote.detach.error;\n        if (error) {\n            var handled = this.dispatch(this.prefix_event('error'), this._context());\n            handled = this.dispatch(this.prefix_event('close'), this._context()) || handled;\n            if (!handled) {\n                EventEmitter.prototype.emit.call(this.connection.container, 'error', new LinkError(error.description, error.condition, this));\n            }\n        } else {\n            this.dispatch(this.prefix_event('close'), this._context());\n        }\n        var self = this;\n        var token = this.state.mark();\n        process.nextTick(function () {\n            if (self.state.marker === token) {\n                self.close();\n                process.nextTick(function () { self.remove(); });\n            }\n        });\n    } else {\n        throw Error('Detach already received');\n    }\n};\n\nfunction is_internal(name) {\n    switch (name) {\n    case 'name':\n    case 'handle':\n    case 'role':\n    case 'initial_delivery_count':\n        return true;\n    default:\n        return false;\n    }\n}\n\n\nvar aliases = [\n    'snd_settle_mode',\n    'rcv_settle_mode',\n    'source',\n    'target',\n    'max_message_size',\n    'offered_capabilities',\n    'desired_capabilities',\n    'properties'\n];\n\nfunction remote_property_shortcut(name) {\n    return function() { return this.remote.attach ? this.remote.attach[name] : undefined; };\n}\n\nlink.init = function (session, name, local_handle, opts, is_receiver) {\n    this.session = session;\n    this.connection = session.connection;\n    this.name = name;\n    this.options = opts === undefined ? {} : opts;\n    this.state = new EndpointState();\n    this.issue_flow = false;\n    this.local = {'handle': local_handle};\n    this.local.attach = frames.attach({'handle':local_handle,'name':name, role:is_receiver});\n    for (var field in this.local.attach) {\n        if (!is_internal(field) && this.options[field] !== undefined) {\n            this.local.attach[field] = this.options[field];\n        }\n    }\n    this.local.detach = frames.detach({'handle':local_handle, 'closed':true});\n    this.remote = {'handle':undefined};\n    this.delivery_count = 0;\n    this.credit = 0;\n    this.observers = new EventEmitter();\n    var self = this;\n    aliases.forEach(function (alias) { Object.defineProperty(self, alias, { get: remote_property_shortcut(alias) }); });\n    Object.defineProperty(this, 'error', { get:  function() { return this.remote.detach ? this.remote.detach.error : undefined; }});\n};\n\nlink._disconnect = function() {\n    this.state.disconnected();\n    if (!this.state.was_open) {\n        this.remove();\n    }\n};\n\nlink._reconnect = function() {\n    this.state.reconnect();\n    this.remote = {'handle':undefined};\n    this.delivery_count = 0;\n    this.credit = 0;\n};\n\nlink.has_credit = function () {\n    return this.credit > 0;\n};\nlink.is_receiver = function () {\n    return this.local.attach.role;\n};\nlink.is_sender = function () {\n    return !this.is_receiver();\n};\nlink._context = function (c) {\n    var context = c ? c : {};\n    if (this.is_receiver()) {\n        context.receiver = this;\n    } else {\n        context.sender = this;\n    }\n    return this.session._context(context);\n};\nlink.get_option = function (name, default_value) {\n    if (this.options[name] !== undefined) return this.options[name];\n    else return this.session.get_option(name, default_value);\n};\n\nvar Sender = function (session, name, local_handle, opts) {\n    this.init(session, name, local_handle, opts, false);\n    this._draining = false;\n    this._drained = false;\n    this.local.attach.initial_delivery_count = 0;\n    this.tag = 0;\n    if (this.get_option('autosettle', true)) {\n        this.observers.on('settled', auto_settle);\n    }\n    var sender = this;\n    if (this.get_option('treat_modified_as_released', true)) {\n        this.observers.on('modified', function (context) {\n            sender.dispatch('released', context);\n        });\n    }\n};\nSender.prototype = Object.create(link);\nSender.prototype.constructor = Sender;\nSender.prototype._get_drain = function () {\n    if (this._draining && this._drained && this.credit) {\n        while (this.credit) {\n            ++this.delivery_count;\n            --this.credit;\n        }\n        return true;\n    } else {\n        return false;\n    }\n};\nSender.prototype.set_drained = function (drained) {\n    this._drained = drained;\n    if (this._draining && this._drained) {\n        this.issue_flow = true;\n    }\n};\nSender.prototype.next_tag = function () {\n    return Buffer.from(new String(this.tag++));\n};\nSender.prototype.sendable = function () {\n    return Boolean(this.credit && this.session.outgoing.available());\n};\nSender.prototype.on_flow = function (frame) {\n    var flow = frame.performative;\n    this.credit = flow.delivery_count + flow.link_credit - this.delivery_count;\n    this._draining = flow.drain;\n    this._drained = this.credit > 0;\n    if (this.is_open()) {\n        this.dispatch('sender_flow', this._context());\n        if (this._draining) {\n            this.dispatch('sender_draining', this._context());\n        }\n        if (this.sendable()) {\n            this.dispatch('sendable', this._context());\n        }\n    }\n};\nSender.prototype.on_transfer = function () {\n    throw Error('got transfer on sending link');\n};\n\nSender.prototype.send = function (msg, tag, format) {\n    var payload = format === undefined ? message.encode(msg) : msg;\n    var delivery = this.session.send(this, tag ? tag : this.next_tag(), payload, format);\n    if (this.local.attach.snd_settle_mode === 1) {\n        delivery.settled = true;\n    }\n    return delivery;\n};\n\nvar Receiver = function (session, name, local_handle, opts) {\n    this.init(session, name, local_handle, opts, true);\n    this.drain = false;\n    this.set_credit_window(this.get_option('credit_window', 1000));\n    if (this.get_option('autoaccept', true)) {\n        this.observers.on('message', auto_accept);\n    }\n    if (this.local.attach.rcv_settle_mode === 1 && this.get_option('autosettle', true)) {\n        this.observers.on('settled', auto_settle);\n    }\n};\nReceiver.prototype = Object.create(link);\nReceiver.prototype.constructor = Receiver;\nReceiver.prototype.on_flow = function (frame) {\n    this.dispatch('receiver_flow', this._context());\n    if (frame.performative.drain) {\n        this.credit = frame.performative.link_credit;\n        this.delivery_count = frame.performative.delivery_count;\n        if (frame.performative.link_credit > 0) console.error('ERROR: received flow with drain set, but non zero credit');\n        else this.dispatch('receiver_drained', this._context());\n    }\n};\nReceiver.prototype.flow = function(credit) {\n    if (credit > 0) {\n        this.credit += credit;\n        this.issue_flow = true;\n        this.connection._register();\n    }\n};\n\nReceiver.prototype.drain_credit = function() {\n    this.drain = true;\n    this.issue_flow = true;\n    this.connection._register();\n};\n\nReceiver.prototype.add_credit = Receiver.prototype.flow;//alias\nReceiver.prototype._get_drain = function () {\n    return this.drain;\n};\n\nReceiver.prototype.set_credit_window = function(credit_window) {\n    if (credit_window > 0) {\n        var flow_controller = new FlowController(credit_window);\n        var listener = flow_controller.update.bind(flow_controller);\n        this.observers.on('message', listener);\n        this.observers.on('receiver_open', listener);\n    }\n};\n\nmodule.exports = {'Sender': Sender, 'Receiver':Receiver};\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar log = require('./log.js');\nvar types = require('./types.js');\n\nvar by_descriptor = {};\nvar unwrappers = {};\nvar wrappers = [];\nvar message = {};\n\nfunction define_section(descriptor, unwrap, wrap) {\n    unwrap.descriptor = descriptor;\n    unwrappers[descriptor.symbolic] = unwrap;\n    unwrappers[Number(descriptor.numeric).toString(10)] = unwrap;\n    if (wrap) {\n        wrappers.push(wrap);\n    }\n}\n\nfunction define_composite_section(def) {\n    var c = types.define_composite(def);\n    message[def.name] = c.create;\n    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;\n    by_descriptor[c.descriptor.symbolic] = c;\n\n    var unwrap = function (msg, section) {\n        var composite = new c(section.value);\n        for (var i = 0; i < def.fields.length; i++) {\n            var f = def.fields[i];\n            var v = composite[f.name];\n            if (v !== undefined && v !== null) {\n                msg[f.name] = v;\n            }\n        }\n    };\n\n    var wrap = function (sections, msg) {\n        sections.push(c.create(msg).described());\n    };\n    define_section(c.descriptor, unwrap, wrap);\n}\n\n\nfunction define_map_section(def, symbolic) {\n    var wrapper = symbolic ? types.wrap_symbolic_map : types.wrap_map;\n    var descriptor = {numeric:def.code};\n    descriptor.symbolic = 'amqp:' + def.name.replace(/_/g, '-') + ':map';\n    var unwrap = function (msg, section) {\n        msg[def.name] = types.unwrap_map_simple(section);\n    };\n    var wrap = function (sections, msg) {\n        if (msg[def.name]) {\n            sections.push(types.described_nc(types.wrap_ulong(descriptor.numeric), wrapper(msg[def.name])));\n        }\n    };\n    define_section(descriptor, unwrap, wrap);\n}\n\nfunction Section(typecode, content, multiple) {\n    this.typecode = typecode;\n    this.content = content;\n    this.multiple = multiple;\n}\n\nSection.prototype.described = function (item) {\n    return types.described(types.wrap_ulong(this.typecode), types.wrap(item || this.content));\n};\n\nSection.prototype.collect_sections = function (sections) {\n    if (this.multiple) {\n        for (var i = 0; i < this.content.length; i++) {\n            sections.push(this.described(this.content[i]));\n        }\n    } else {\n        sections.push(this.described());\n    }\n};\n\ndefine_composite_section({\n    name:'header',\n    code:0x70,\n    fields:[\n        {name:'durable', type:'boolean', default_value:false},\n        {name:'priority', type:'ubyte', default_value:4},\n        {name:'ttl', type:'uint'},\n        {name:'first_acquirer', type:'boolean', default_value:false},\n        {name:'delivery_count', type:'uint', default_value:0}\n    ]\n});\ndefine_map_section({name:'delivery_annotations', code:0x71}, true);\ndefine_map_section({name:'message_annotations', code:0x72}, true);\ndefine_composite_section({\n    name:'properties',\n    code:0x73,\n    fields:[\n        {name:'message_id', type:'message_id'},\n        {name:'user_id', type:'binary'},\n        {name:'to', type:'string'},\n        {name:'subject', type:'string'},\n        {name:'reply_to', type:'string'},\n        {name:'correlation_id', type:'message_id'},\n        {name:'content_type', type:'symbol'},\n        {name:'content_encoding', type:'symbol'},\n        {name:'absolute_expiry_time', type:'timestamp'},\n        {name:'creation_time', type:'timestamp'},\n        {name:'group_id', type:'string'},\n        {name:'group_sequence', type:'uint'},\n        {name:'reply_to_group_id', type:'string'}\n    ]\n});\ndefine_map_section({name:'application_properties', code:0x74});\n\nfunction unwrap_body_section (msg, section, typecode) {\n    if (msg.body === undefined) {\n        msg.body = new Section(typecode, types.unwrap(section));\n    } else if (msg.body.constructor === Section && msg.body.typecode === typecode) {\n        if (msg.body.multiple) {\n            msg.body.content.push(types.unwrap(section));\n        } else {\n            msg.body.multiple = true;\n            msg.body.content = [msg.body.content, types.unwrap(section)];\n        }\n    }\n}\n\ndefine_section({numeric:0x75, symbolic:'amqp:data:binary'}, function (msg, section) { unwrap_body_section(msg, section, 0x75); });\ndefine_section({numeric:0x76, symbolic:'amqp:amqp-sequence:list'}, function (msg, section) { unwrap_body_section(msg, section, 0x76); });\ndefine_section({numeric:0x77, symbolic:'amqp:value:*'}, function (msg, section) { msg.body = types.unwrap(section); });\n\ndefine_map_section({name:'footer', code:0x78});\n\n\nfunction wrap_body (sections, msg) {\n    if (msg.body && msg.body.collect_sections) {\n        msg.body.collect_sections(sections);\n    } else {\n        sections.push(types.described(types.wrap_ulong(0x77), types.wrap(msg.body)));\n    }\n}\n\nwrappers.push(wrap_body);\n\nmessage.data_section = function (data) {\n    return new Section(0x75, data);\n};\n\nmessage.sequence_section = function (list) {\n    return new Section(0x76, list);\n};\n\nmessage.data_sections = function (data_elements) {\n    return new Section(0x75, data_elements, true);\n};\n\nmessage.sequence_sections = function (lists) {\n    return new Section(0x76, lists, true);\n};\n\nfunction copy(src, tgt) {\n    for (var k in src) {\n        var v = src[k];\n        if (typeof v === 'object') {\n            copy(v, tgt[k]);\n        } else {\n            tgt[k] = v;\n        }\n    }\n}\n\nfunction Message(o) {\n    if (o) {\n        copy(o, this);\n    }\n}\n\nMessage.prototype.toJSON = function () {\n    var o = {};\n    for (var key in this) {\n        if (typeof this[key] === 'function') continue;\n        o[key] = this[key];\n    }\n    return o;\n};\n\nMessage.prototype.toString = function () {\n    return JSON.stringify(this.toJSON());\n};\n\n\nmessage.encode = function(msg) {\n    var sections = [];\n    wrappers.forEach(function (wrapper_fn) { wrapper_fn(sections, msg); });\n    var writer = new types.Writer();\n    for (var i = 0; i < sections.length; i++) {\n        log.message('Encoding section %d of %d: %o', (i+1), sections.length, sections[i]);\n        writer.write(sections[i]);\n    }\n    var data = writer.toBuffer();\n    log.message('encoded %d bytes', data.length);\n    return data;\n};\n\nmessage.decode = function(buffer) {\n    var msg = new Message();\n    var reader = new types.Reader(buffer);\n    while (reader.remaining()) {\n        var s = reader.read();\n        log.message('decoding section: %o of type: %o', s, s.descriptor);\n        if (s.descriptor) {\n            var unwrap = unwrappers[s.descriptor.value];\n            if (unwrap) {\n                unwrap(msg, s);\n            } else {\n                console.warn('WARNING: did not recognise message section with descriptor ' + s.descriptor);\n            }\n        } else {\n            console.warn('WARNING: expected described message section got ' + JSON.stringify(s));\n        }\n    }\n    return msg;\n};\n\nvar outcomes = {};\n\nfunction define_outcome(def) {\n    var c = types.define_composite(def);\n    c.composite_type = def.name;\n    message[def.name] = c.create;\n    outcomes[Number(c.descriptor.numeric).toString(10)] = c;\n    outcomes[c.descriptor.symbolic] = c;\n    message['is_' + def.name] = function (o) {\n        if (o && o.descriptor) {\n            var c = outcomes[o.descriptor.value];\n            if (c) {\n                return c.descriptor.numeric === def.code;\n            }\n        }\n        return false;\n    };\n}\n\nmessage.unwrap_outcome = function (outcome) {\n    if (outcome && outcome.descriptor) {\n        var c = outcomes[outcome.descriptor.value];\n        if (c) {\n            return new c(outcome.value);\n        }\n    }\n    console.error('unrecognised outcome: ' + JSON.stringify(outcome));\n    return outcome;\n};\n\nmessage.are_outcomes_equivalent = function(a, b) {\n    if (a === undefined && b === undefined) return true;\n    else if (a === undefined || b === undefined) return false;\n    else return a.descriptor.value === b.descriptor.value && a.descriptor.value === 0x24;//only batch accepted\n};\n\ndefine_outcome({\n    name:'received',\n    code:0x23,\n    fields:[\n        {name:'section_number', type:'uint', mandatory:true},\n        {name:'section_offset', type:'ulong', mandatory:true}\n    ]});\ndefine_outcome({name:'accepted', code:0x24, fields:[]});\ndefine_outcome({name:'rejected', code:0x25, fields:[{name:'error', type:'error'}]});\ndefine_outcome({name:'released', code:0x26, fields:[]});\ndefine_outcome({\n    name:'modified',\n    code:0x27,\n    fields:[\n        {name:'delivery_failed', type:'boolean'},\n        {name:'undeliverable_here', type:'boolean'},\n        {name:'message_annotations', type:'map'}\n    ]});\n\nmodule.exports = message;\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar types = require('./types.js');\n\nvar terminus = {};\nvar by_descriptor = {};\n\nfunction define_terminus(def) {\n    var c = types.define_composite(def);\n    terminus[def.name] = c.create;\n    by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;\n    by_descriptor[c.descriptor.symbolic] = c;\n}\n\nterminus.unwrap = function(field) {\n    if (field && field.descriptor) {\n        var c = by_descriptor[field.descriptor.value];\n        if (c) {\n            return new c(field.value);\n        } else {\n            console.warn('Unknown terminus: ' + field.descriptor);\n        }\n    }\n    return null;\n};\n\ndefine_terminus({\n    name: 'source',\n    code: 0x28,\n    fields: [\n        {name: 'address', type: 'string'},\n        {name: 'durable', type: 'uint', default_value: 0},\n        {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},\n        {name: 'timeout', type: 'uint', default_value: 0},\n        {name: 'dynamic', type: 'boolean', default_value: false},\n        {name: 'dynamic_node_properties', type: 'symbolic_map'},\n        {name: 'distribution_mode', type: 'symbol'},\n        {name: 'filter', type: 'symbolic_map'},\n        {name: 'default_outcome', type: '*'},\n        {name: 'outcomes', type: 'symbol', multiple: true},\n        {name: 'capabilities', type: 'symbol', multiple: true}\n    ]\n});\n\ndefine_terminus({\n    name: 'target',\n    code: 0x29,\n    fields: [\n        {name: 'address', type: 'string'},\n        {name: 'durable', type: 'uint', default_value: 0},\n        {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},\n        {name: 'timeout', type: 'uint', default_value: 0},\n        {name: 'dynamic', type: 'boolean', default_value: false},\n        {name: 'dynamic_node_properties', type: 'symbolic_map'},\n        {name: 'capabilities', type: 'symbol', multiple: true}\n    ]\n});\n\nmodule.exports = terminus;\n","/*\n * Copyright 2018 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar ReceiverEvents;\n(function (ReceiverEvents) {\n    /**\n     * @property {string} message Raised when a message is received.\n     */\n    ReceiverEvents['message'] = 'message';\n    /**\n     * @property {string} receiverOpen Raised when the remote peer indicates the link is\n     * open (i.e. attached in AMQP parlance).\n     */\n    ReceiverEvents['receiverOpen'] = 'receiver_open';\n    /**\n     * @property {string} receiverDrained Raised when the remote peer\n     * indicates that it has drained all credit (and therefore there\n     * are no more messages at present that it can send).\n     */\n    ReceiverEvents['receiverDrained'] = 'receiver_drained';\n    /**\n     * @property {string} receiverFlow Raised when a flow is received for receiver.\n     */\n    ReceiverEvents['receiverFlow'] = 'receiver_flow';\n    /**\n     * @property {string} receiverError Raised when the remote peer\n     * closes the receiver with an error. The context may also have an\n     * error property giving some information about the reason for the\n     * error.\n     */\n    ReceiverEvents['receiverError'] = 'receiver_error';\n    /**\n     * @property {string} receiverClose Raised when the remote peer indicates the link is closed.\n     */\n    ReceiverEvents['receiverClose'] = 'receiver_close';\n    /**\n     * @property {string} settled Raised when the receiver link receives a disposition.\n     */\n    ReceiverEvents['settled'] = 'settled';\n})(ReceiverEvents || (ReceiverEvents = {}));\n\nvar SenderEvents;\n(function (SenderEvents) {\n    /**\n     * @property {string} sendable Raised when the sender has sufficient credit to be able\n     * to transmit messages to its peer.\n     */\n    SenderEvents['sendable'] = 'sendable';\n    /**\n     * @property {string} senderOpen Raised when the remote peer indicates the link is\n     * open (i.e. attached in AMQP parlance).\n     */\n    SenderEvents['senderOpen'] = 'sender_open';\n    /**\n     * @property {string} senderDraining Raised when the remote peer\n     * requests that the sender drain its credit; sending all\n     * available messages within the credit limit and ensuring credit\n     * is used up..\n     */\n    SenderEvents['senderDraining'] = 'sender_draining';\n    /**\n     * @property {string} senderFlow Raised when a flow is received for sender.\n     */\n    SenderEvents['senderFlow'] = 'sender_flow';\n    /**\n     * @property {string} senderError Raised when the remote peer\n     * closes the sender with an error. The context may also have an\n     * error property giving some information about the reason for the\n     * error.\n     */\n    SenderEvents['senderError'] = 'sender_error';\n    /**\n     * @property {string} senderClose Raised when the remote peer indicates the link is closed.\n     */\n    SenderEvents['senderClose'] = 'sender_close';\n    /**\n     * @property {string} accepted Raised when a sent message is accepted by the peer.\n     */\n    SenderEvents['accepted'] = 'accepted';\n    /**\n     * @property {string} released Raised when a sent message is released by the peer.\n     */\n    SenderEvents['released'] = 'released';\n    /**\n     * @property {string} rejected Raised when a sent message is rejected by the peer.\n     */\n    SenderEvents['rejected'] = 'rejected';\n    /**\n     * @property {string} modified Raised when a sent message is modified by the peer.\n     */\n    SenderEvents['modified'] = 'modified';\n    /**\n     * @property {string} settled Raised when the sender link receives a disposition.\n     */\n    SenderEvents['settled'] = 'settled';\n})(SenderEvents || (SenderEvents = {}));\n\n\nvar SessionEvents;\n(function (SessionEvents) {\n    /**\n     * @property {string} sessionOpen Raised when the remote peer indicates the session is\n     * open (i.e. attached in AMQP parlance).\n     */\n    SessionEvents['sessionOpen'] = 'session_open';\n    /**\n     * @property {string} sessionError Raised when the remote peer receives an error. The context\n     * may also have an error property giving some information about the reason for the error.\n     */\n    SessionEvents['sessionError'] = 'session_error';\n    /**\n     * @property {string} sessionClose Raised when the remote peer indicates the session is closed.\n     */\n    SessionEvents['sessionClose'] = 'session_close';\n    /**\n     * @property {string} settled Raised when the session receives a disposition.\n     */\n    SessionEvents['settled'] = 'settled';\n})(SessionEvents || (SessionEvents = {}));\n\nvar ConnectionEvents;\n(function (ConnectionEvents) {\n    /**\n     * @property {string} connectionOpen Raised when the remote peer indicates the connection is open.\n     */\n    ConnectionEvents['connectionOpen'] = 'connection_open';\n    /**\n     * @property {string} connectionClose Raised when the remote peer indicates the connection is closed.\n     */\n    ConnectionEvents['connectionClose'] = 'connection_close';\n    /**\n     * @property {string} connectionError Raised when the remote peer indicates an error occurred on\n     * the connection.\n     */\n    ConnectionEvents['connectionError'] = 'connection_error';\n    /**\n     * @property {string} protocolError Raised when a protocol error is received on the underlying socket.\n     */\n    ConnectionEvents['protocolError'] = 'protocol_error',\n    /**\n     * @property {string} error Raised when an error is received on the underlying socket.\n     */\n    ConnectionEvents['error'] = 'error',\n    /**\n     * @property {string} disconnected Raised when the underlying tcp connection is lost. The context\n     * has a reconnecting property which is true if the library is attempting to automatically reconnect\n     * and false if it has reached the reconnect limit. If reconnect has not been enabled or if the connection\n     * is a tcp server, then the reconnecting property is undefined. The context may also have an error\n     * property giving some information about the reason for the disconnect.\n     */\n    ConnectionEvents['disconnected'] = 'disconnected';\n    /**\n     * @property {string} settled Raised when the connection receives a disposition.\n     */\n    ConnectionEvents['settled'] = 'settled';\n})(ConnectionEvents || (ConnectionEvents = {}));\n\nmodule.exports = {\n    ReceiverEvents: ReceiverEvents,\n    SenderEvents: SenderEvents,\n    SessionEvents: SessionEvents,\n    ConnectionEvents: ConnectionEvents\n};\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction nulltransform(data) { return data; }\n\nfunction from_arraybuffer(data) {\n    if (data instanceof ArrayBuffer) return Buffer.from(new Uint8Array(data));\n    else return Buffer.from(data);\n}\n\nfunction to_typedarray(data) {\n    return new Uint8Array(data);\n}\n\nfunction wrap(ws) {\n    var data_recv = nulltransform;\n    var data_send = nulltransform;\n    if (ws.binaryType) {\n        ws.binaryType = 'arraybuffer';\n        data_recv = from_arraybuffer;\n        data_send = to_typedarray;\n    }\n    return {\n        end: function() {\n            ws.close();\n        },\n        write: function(data) {\n            try {\n                ws.send(data_send(data), {binary:true});\n            } catch (e) {\n                ws.onerror(e);\n            }\n        },\n        on: function(event, handler) {\n            if (event === 'data') {\n                ws.onmessage = function(msg_evt) {\n                    handler(data_recv(msg_evt.data));\n                };\n            } else if (event === 'end') {\n                ws.onclose = handler;\n            } else if (event === 'error') {\n                ws.onerror = handler;\n            } else {\n                console.error('ERROR: Attempt to set unrecognised handler on websocket wrapper: ' + event);\n            }\n        },\n        get_id_string: function() {\n            return ws.url;\n        }\n    };\n}\n\nmodule.exports = {\n\n    'connect': function(Impl) {\n        return function (url, protocols, options) {\n            return function () {\n                return {\n                    connect: function(port_ignore, host_ignore, options_ignore, callback) {\n                        var c = new Impl(url, protocols, options);\n                        c.onopen = callback;\n                        return wrap(c);\n                    }\n                };\n            };\n        };\n    },\n    'wrap': wrap\n};\n","/*\n * Copyright 2015 Red Hat Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar amqp_types = require('./types.js');\n\nmodule.exports = {\n    selector : function (s) {\n        return {'jms-selector':amqp_types.wrap_described(s, 0x468C00000004)};\n    }\n};\n"]}