{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst fs = require('fs');\nconst os = require('os');\nconst crypto = require('crypto');\n\n/**\n * Load *.json file synchronous. Don't use require('*.json')\n * to load *.json files, it will cached in process.\n * @param {String} filename absolute file path\n * @return {Object} a parsed object\n */\nexports.loadJSONSync = function (filename) {\n  // strip BOM\n  var content = fs.readFileSync(filename, 'utf8');\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  try {\n    return JSON.parse(content);\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n/**\n * Encoding a string to Buffer safely\n * @param {String} str string.\n * @param {String} encoding. optional.\n * @return {Buffer} encoded buffer\n */\nexports.encode = function (str, encoding) {\n  if (typeof str !== 'string') {\n    str = '' + str;\n  }\n\n  return Buffer.from(str, encoding);\n};\n\n/**\n * Generate a haser with specfied algorithm\n * @param {String} algorithm can be md5, etc.\n * @return {Function} a haser with specfied algorithm\n */\nexports.makeHasher = function (algorithm) {\n  return function (data, encoding) {\n    var shasum = crypto.createHash(algorithm);\n    shasum.update(data);\n    return shasum.digest(encoding);\n  };\n};\n\nexports.createHash = exports.makeHasher;\n\n/**\n * Get md5 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} encoding optional. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.md5 = exports.makeHasher('md5');\n\n/**\n * Get sha1 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} key the key.\n * @param {String} encoding optionnal. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.createHmac = function (algorithm) {\n  return function (data, key, encoding) {\n    return crypto.createHmac(algorithm, key).update(data).digest(encoding);\n  };\n};\n\n/**\n * Get sha1 hash digests of data\n * @param {String|Buffer} data data.\n * @param {String} key the key.\n * @param {String} encoding optionnal. can be 'hex', 'binary', 'base64'.\n * @return {String|Buffer} if no encoding is provided, a buffer is returned.\n */\nexports.sha1 = exports.createHmac('sha1');\n\n/**\n * Get a random value in a range\n * @param {Number} min range start.\n * @param {Number} max range end.\n */\nexports.random = function (min, max) {\n  return Math.floor(min + Math.random() * (max - min));\n};\n\n/**\n * Generate a nonce string\n * @return {String} a nonce string.\n */\nexports.makeNonce = (function () {\n  var counter = 0;\n  var last;\n  const machine = os.hostname();\n  const pid = process.pid;\n\n  return function () {\n    var val = Math.floor(Math.random() * 1000000000000);\n    if (val === last) {\n      counter++;\n    } else {\n      counter = 0;\n    }\n\n    last = val;\n\n    var uid = `${machine}${pid}${val}${counter}`;\n    return exports.md5(uid, 'hex');\n  };\n}());\n\n/**\n * Pad a number as \\d\\d format\n * @param {Number} num a number that less than 100.\n * @return {String} if number less than 10, pad with 0,\n *  otherwise, returns string of number.\n */\nexports.pad2 = function (num) {\n  if (num < 10) {\n    return '0' + num;\n  }\n  return '' + num;\n};\n\n/**\n * Pad a number as \\d\\d\\d format\n * @param {Number} num a number that less than 1000.\n * @return {String} if number less than 100, pad with 0,\n *  otherwise, returns string of number.\n */\nexports.pad3 = function (num) {\n  if (num < 10) {\n    return '00' + num;\n  } else if (num < 100) {\n    return '0' + num;\n  }\n  return '' + num;\n};\n\n/**\n * Return the YYYYMMDD format of a date.\n * @param {Date} date a Date object.\n * @return {String} the YYYYMMDD format.\n */\nexports.getYYYYMMDD = function (date) {\n  var YYYY = date.getFullYear();\n  var MM = exports.pad2(date.getMonth() + 1);\n  var DD = exports.pad2(date.getDate());\n  return '' + YYYY + MM + DD;\n};\n\n/**\n * sleep a while.\n * @param {Number} in milliseconds\n * @return {Promise} a Promise\n */\nexports.sleep = function (ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\n/**\n * Get the IPv4 address\n * @return {String} the IPv4 address, or empty string\n */\nexports.getIPv4 = function () {\n  var interfaces = os.networkInterfaces();\n  var keys = Object.keys(interfaces);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var addresses = interfaces[key];\n    for (var j = 0; j < addresses.length; j++) {\n      var item = addresses[j];\n      if (!item.internal && item.family === 'IPv4') {\n        return item.address;\n      }\n    }\n  }\n\n  // without non-internal address\n  return '';\n};\n\n/**\n * Get the Mac address\n * @return {String} the Mac address\n */\nexports.getMac = function () {\n  var interfaces = os.networkInterfaces();\n  var keys = Object.keys(interfaces);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var addresses = interfaces[key];\n    for (var j = 0; j < addresses.length; j++) {\n      var item = addresses[j];\n      if (!item.internal && item.family === 'IPv4') {\n        return item.mac;\n      }\n    }\n  }\n\n  // without non-internal address\n  return '00:00:00:00:00:00';\n};\n\n/**\n * Read all bytes from a readable\n * @return {Readable} the readable stream\n * @return {Promise} a Promise with all bytes\n */\nexports.readAll = function (readable) {\n  return new Promise((resolve, reject) => {\n    var onError, onData, onEnd;\n    var cleanup = function (err) {\n      // cleanup\n      readable.removeListener('error', onError);\n      readable.removeListener('data', onData);\n      readable.removeListener('end', onEnd);\n    };\n\n    var bufs = [];\n    var size = 0;\n\n    onData = function (buf) {\n      bufs.push(buf);\n      size += buf.length;\n    };\n\n    onError = function (err) {\n      cleanup();\n      reject(err);\n    };\n\n    onEnd = function () {\n      cleanup();\n      resolve(Buffer.concat(bufs, size));\n    };\n\n    readable.on('error', onError);\n    readable.on('data', onData);\n    readable.on('end', onEnd);\n  });\n};\n"]}