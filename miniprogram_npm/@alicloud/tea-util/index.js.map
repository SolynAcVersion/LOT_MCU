{"version":3,"sources":["client.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RuntimeOptions = void 0;\nconst stream_1 = require(\"stream\");\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nconst kitx = __importStar(require(\"kitx\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst os_1 = require(\"os\");\nconst DEFAULT_USER_AGENT = `AlibabaCloud (${os_1.platform()}; ${os_1.arch()}) Node.js/${process.version} Core/1.0.1 TeaDSL/1`;\nclass RuntimeOptions extends $tea.Model {\n    constructor(map) {\n        super(map);\n    }\n    static names() {\n        return {\n            autoretry: 'autoretry',\n            ignoreSSL: 'ignoreSSL',\n            key: 'key',\n            cert: 'cert',\n            ca: 'ca',\n            maxAttempts: 'max_attempts',\n            backoffPolicy: 'backoff_policy',\n            backoffPeriod: 'backoff_period',\n            readTimeout: 'readTimeout',\n            connectTimeout: 'connectTimeout',\n            httpProxy: 'httpProxy',\n            httpsProxy: 'httpsProxy',\n            noProxy: 'noProxy',\n            maxIdleConns: 'maxIdleConns',\n            keepAlive: 'keepAlive',\n        };\n    }\n    static types() {\n        return {\n            autoretry: 'boolean',\n            ignoreSSL: 'boolean',\n            key: 'string',\n            cert: 'string',\n            ca: 'string',\n            maxAttempts: 'number',\n            backoffPolicy: 'string',\n            backoffPeriod: 'number',\n            readTimeout: 'number',\n            connectTimeout: 'number',\n            httpProxy: 'string',\n            httpsProxy: 'string',\n            noProxy: 'string',\n            maxIdleConns: 'number',\n            keepAlive: 'boolean',\n        };\n    }\n}\nexports.RuntimeOptions = RuntimeOptions;\nfunction read(readable) {\n    return new Promise((resolve, reject) => {\n        let onData, onError, onEnd;\n        var cleanup = function () {\n            // cleanup\n            readable.removeListener('error', onError);\n            readable.removeListener('data', onData);\n            readable.removeListener('end', onEnd);\n        };\n        var bufs = [];\n        var size = 0;\n        onData = function (buf) {\n            bufs.push(buf);\n            size += buf.length;\n        };\n        onError = function (err) {\n            cleanup();\n            reject(err);\n        };\n        onEnd = function () {\n            cleanup();\n            resolve(Buffer.concat(bufs, size));\n        };\n        readable.on('error', onError);\n        readable.on('data', onData);\n        readable.on('end', onEnd);\n    });\n}\nclass Client {\n    static toString(buff) {\n        return buff.toString();\n    }\n    static parseJSON(text) {\n        return JSON.parse(text);\n    }\n    static async readAsBytes(stream) {\n        return await read(stream);\n    }\n    static async readAsString(stream) {\n        let buff = await Client.readAsBytes(stream);\n        return Client.toString(buff);\n    }\n    static async readAsJSON(stream) {\n        return Client.parseJSON(await Client.readAsString(stream));\n    }\n    static getNonce() {\n        return kitx.makeNonce();\n    }\n    static getDateUTCString() {\n        const now = new Date();\n        return now.toUTCString();\n    }\n    static defaultString(real, defaultValue) {\n        return real || defaultValue;\n    }\n    static defaultNumber(real, defaultValue) {\n        return real || defaultValue;\n    }\n    static toFormString(val) {\n        return querystring_1.default.stringify(val);\n    }\n    static toJSONString(val) {\n        if (typeof val === 'string') {\n            return val;\n        }\n        return JSON.stringify(val);\n    }\n    static toBytes(val) {\n        return Buffer.from(val);\n    }\n    static empty(val) {\n        return !val;\n    }\n    static equalString(val1, val2) {\n        return val1 === val2;\n    }\n    static equalNumber(val1, val2) {\n        return val1 === val2;\n    }\n    static isUnset(value) {\n        if (typeof value === 'undefined') {\n            return true;\n        }\n        if (value === null) {\n            return true;\n        }\n        return false;\n    }\n    static stringifyMapValue(m) {\n        if (!m) {\n            return m;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(m)) {\n            if (typeof value === 'undefined' || value === null) {\n                continue;\n            }\n            result[key] = String(value);\n        }\n        return result;\n    }\n    static anyifyMapValue(m) {\n        return m;\n    }\n    static assertAsBoolean(value) {\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        throw new Error(`The value is not a boolean`);\n    }\n    static assertAsString(value) {\n        if (typeof value === 'string') {\n            return value;\n        }\n        throw new Error(`The value is not a string`);\n    }\n    static assertAsNumber(value) {\n        if (typeof value === 'number') {\n            return value;\n        }\n        throw new Error(`The value is not a number`);\n    }\n    /**\n     * Assert a value, if it is a integer, return it, otherwise throws\n     * @return the integer value\n     */\n    static assertAsInteger(value) {\n        if (Number.isInteger(value)) {\n            return value;\n        }\n        throw new Error(`The value is not a int number`);\n    }\n    static assertAsMap(value) {\n        if (value && typeof value === 'object' && !Array.isArray(value)) {\n            return value;\n        }\n        throw new Error(`The value is not a object`);\n    }\n    static assertAsArray(value) {\n        if (Array.isArray(value)) {\n            return value;\n        }\n        throw new Error(`The value is not array`);\n    }\n    static assertAsBytes(value) {\n        if (Buffer.isBuffer(value)) {\n            return value;\n        }\n        throw new Error(`The value is not bytes`);\n    }\n    static getUserAgent(userAgent) {\n        if (!userAgent || !userAgent.length) {\n            return DEFAULT_USER_AGENT;\n        }\n        return DEFAULT_USER_AGENT + \" \" + userAgent;\n    }\n    static is2xx(code) {\n        return code >= 200 && code < 300;\n    }\n    static is3xx(code) {\n        return code >= 300 && code < 400;\n    }\n    static is4xx(code) {\n        return code >= 400 && code < 500;\n    }\n    static is5xx(code) {\n        return code >= 500 && code < 600;\n    }\n    static validateModel(m) {\n    }\n    static toMap(inputModel) {\n        return $tea.toMap(inputModel);\n    }\n    static async sleep(millisecond) {\n        return new Promise(resolve => {\n            setTimeout(() => {\n                resolve();\n            }, millisecond);\n        });\n    }\n    static toArray(input) {\n        if (!(input instanceof Array)) {\n            return null;\n        }\n        let ret = [];\n        input.forEach((model) => {\n            if (!model) {\n                return;\n            }\n            ret.push($tea.toMap(model));\n        });\n        return ret;\n    }\n    /**\n     * Assert a value, if it is a readable, return it, otherwise throws\n     * @return the readable value\n     */\n    static assertAsReadable(value) {\n        if (value instanceof stream_1.Readable) {\n            return value;\n        }\n        throw new Error(`The value is not a readable`);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map"]}