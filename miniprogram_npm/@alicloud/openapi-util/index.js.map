{"version":3,"sources":["client.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This file is auto-generated, don't edit it\n/**\n * This is for OpenApi Util\n */\nconst $tea = __importStar(require(\"@alicloud/tea-typescript\"));\nconst tea_util_1 = __importDefault(require(\"@alicloud/tea-util\"));\nconst kitx_1 = __importDefault(require(\"kitx\"));\nconst querystring_1 = __importDefault(require(\"querystring\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst PEM_BEGIN = \"-----BEGIN PRIVATE KEY-----\\n\";\nconst PEM_END = \"\\n-----END PRIVATE KEY-----\";\nfunction replaceRepeatList(target, repeat, prefix) {\n    if (prefix) {\n        prefix = prefix + '.';\n    }\n    for (var i = 0; i < repeat.length; i++) {\n        var item = repeat[i];\n        let key = prefix + (i + 1);\n        if (typeof item === 'undefined' || item == null) {\n            continue;\n        }\n        if (Array.isArray(item)) {\n            replaceRepeatList(target, item, key);\n        }\n        else if (item instanceof Object) {\n            flatMap(target, item, key);\n        }\n        else {\n            target[key] = item.toString();\n        }\n    }\n}\nfunction flatMap(target, params, prefix = '') {\n    if (prefix) {\n        prefix = prefix + '.';\n    }\n    params = toMap(params);\n    let keys = Object.keys(params);\n    for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let value = params[key];\n        key = prefix + key;\n        if (typeof value === 'undefined' || value == null) {\n            continue;\n        }\n        if (Array.isArray(value)) {\n            replaceRepeatList(target, value, key);\n        }\n        else if (value instanceof Object) {\n            flatMap(target, value, key);\n        }\n        else {\n            target[key] = value.toString();\n        }\n    }\n    return target;\n}\nfunction filter(value) {\n    return value.replace(/[\\t\\n\\r\\f]/g, ' ');\n}\nfunction getCanonicalizedHeaders(headers) {\n    const prefix = 'x-acs-';\n    const keys = Object.keys(headers);\n    const canonicalizedKeys = [];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key.startsWith(prefix)) {\n            canonicalizedKeys.push(key);\n        }\n    }\n    canonicalizedKeys.sort();\n    var result = '';\n    for (let i = 0; i < canonicalizedKeys.length; i++) {\n        const key = canonicalizedKeys[i];\n        result += `${key}:${filter(headers[key]).trim()}\\n`;\n    }\n    return result;\n}\nfunction getCanonicalizedResource(uriPattern, query) {\n    const keys = !query ? [] : Object.keys(query).sort();\n    if (keys.length === 0) {\n        return uriPattern;\n    }\n    var result = [];\n    for (var i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        result.push(`${key}=${query[key]}`);\n    }\n    return `${uriPattern}?${result.join('&')}`;\n}\nfunction getAuthorizationQueryString(query) {\n    let canonicalQueryArray = [];\n    const keys = !query ? [] : Object.keys(query).sort();\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        let param = key + '=';\n        if (typeof query[key] !== 'undefined' && query[key] !== null) {\n            param = param + encode(query[key]);\n        }\n        canonicalQueryArray.push(param);\n    }\n    return canonicalQueryArray.join('&');\n}\nfunction getAuthorizationHeaders(header) {\n    let canonicalheaders = \"\";\n    let tmp = {};\n    const keys = !header ? [] : Object.keys(header);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const lowerKey = keys[i].toLowerCase();\n        if (lowerKey.startsWith(\"x-acs-\") || lowerKey === \"host\" || lowerKey === \"content-type\") {\n            if (tmp[lowerKey]) {\n                tmp[lowerKey].push((header[key] || \"\").trim());\n            }\n            else {\n                tmp[lowerKey] = [(header[key] || \"\").trim()];\n            }\n        }\n    }\n    var hsKeys = Object.keys(tmp).sort();\n    for (let i = 0; i < hsKeys.length; i++) {\n        const hsKey = hsKeys[i];\n        let listSort = tmp[hsKey].sort();\n        canonicalheaders += `${hsKey}:${listSort.join(\",\")}\\n`;\n    }\n    return { canonicalheaders, hsKeys };\n}\nfunction encode(str) {\n    var result = encodeURIComponent(str);\n    return result.replace(/!/g, '%21')\n        .replace(/'/g, '%27')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n        .replace(/\\*/g, '%2A');\n}\nfunction normalize(params) {\n    var list = [];\n    var flated = {};\n    flatMap(flated, params);\n    var keys = Object.keys(flated).sort();\n    for (let i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = flated[key];\n        list.push([encode(key), encode(value)]);\n    }\n    return list;\n}\nfunction canonicalize(normalized) {\n    var fields = [];\n    for (var i = 0; i < normalized.length; i++) {\n        var [key, value] = normalized[i];\n        fields.push(key + '=' + value);\n    }\n    return fields.join('&');\n}\nfunction isModelClass(t) {\n    if (!t) {\n        return false;\n    }\n    return typeof t.types === 'function' && typeof t.names === 'function';\n}\nfunction isObjectOrArray(t) {\n    return Array.isArray(t) || (t instanceof Object && typeof t !== 'function');\n}\nfunction toMap(input) {\n    if (!isObjectOrArray(input)) {\n        return null;\n    }\n    else if (input instanceof $tea.Model) {\n        return $tea.toMap(input);\n    }\n    else if (input && input.toMap && typeof input.toMap === 'function') {\n        // 解决跨版本 Model 不互认的问题\n        return input.toMap();\n    }\n    else if (Array.isArray(input)) {\n        const result = [];\n        input.forEach((value) => {\n            if (isObjectOrArray(value)) {\n                result.push(toMap(value));\n            }\n            else {\n                result.push(value);\n            }\n        });\n        return result;\n    }\n    else if (input instanceof Object) {\n        const result = {};\n        Object.entries(input).forEach(([key, value]) => {\n            if (isObjectOrArray(value)) {\n                result[key] = toMap(value);\n            }\n            else {\n                result[key] = value;\n            }\n        });\n        return result;\n    }\n}\nclass Client {\n    /**\n     * Convert all params of body other than type of readable into content\n     * @param input source Model\n     * @param output target Model\n     * @return void\n     */\n    static convert(input, output) {\n        if (!output) {\n            return;\n        }\n        let inputModel = Object.assign({}, input);\n        let constructor = output.constructor;\n        let types = constructor.types();\n        // let constructor = <any>output.constructor;\n        for (let key of Object.keys(constructor.names())) {\n            if (inputModel[key] !== null && inputModel[key] !== undefined) {\n                if (isModelClass(types[key])) {\n                    output[key] = new types[key](output[key]);\n                    Client.convert(inputModel[key], output[key]);\n                }\n                else if (types[key] && types[key].type === 'array') {\n                    output[key] = inputModel[key].map(function (d) {\n                        if (isModelClass(types[key].itemType)) {\n                            var item = new types[key].itemType({});\n                            Client.convert(d, item);\n                            return item;\n                        }\n                        return d;\n                    });\n                }\n                else if (types[key] && types[key].type === 'map') {\n                    output[key] = {};\n                    Object.keys(inputModel[key]).map(function (d) {\n                        if (isModelClass(types[key].valueType)) {\n                            var item = new types[key].valueType({});\n                            Client.convert(inputModel[key][d], item);\n                            output[key][d] = item;\n                        }\n                        else {\n                            output[key][d] = inputModel[key][d];\n                        }\n                    });\n                }\n                else {\n                    output[key] = inputModel[key];\n                }\n            }\n        }\n    }\n    /**\n     * Get the string to be signed according to request\n     * @param request  which contains signed messages\n     * @return the signed string\n     */\n    static getStringToSign(request) {\n        const method = request.method;\n        const accept = request.headers['accept'];\n        const contentMD5 = request.headers['content-md5'] || '';\n        const contentType = request.headers['content-type'] || '';\n        const date = request.headers['date'] || '';\n        const header = `${method}\\n${accept}\\n${contentMD5}\\n${contentType}\\n${date}\\n`;\n        const canonicalizedHeaders = getCanonicalizedHeaders(request.headers);\n        const canonicalizedResource = getCanonicalizedResource(request.pathname, request.query);\n        return `${header}${canonicalizedHeaders}${canonicalizedResource}`;\n    }\n    /**\n     * Get signature according to stringToSign, secret\n     * @param stringToSign  the signed string\n     * @param secret accesskey secret\n     * @return the signature\n     */\n    static getROASignature(stringToSign, secret) {\n        const utf8Buff = Buffer.from(stringToSign, 'utf8');\n        return kitx_1.default.sha1(utf8Buff, secret, 'base64');\n    }\n    /**\n     * Parse filter into a form string\n     * @param filter object\n     * @return the string\n     */\n    static toForm(filter) {\n        if (!filter) {\n            return '';\n        }\n        let target = {};\n        flatMap(target, filter);\n        return tea_util_1.default.toFormString(target);\n    }\n    /**\n     * Get timestamp\n     * @return the timestamp string\n     */\n    static getTimestamp() {\n        let date = new Date();\n        let YYYY = date.getUTCFullYear();\n        let MM = kitx_1.default.pad2(date.getUTCMonth() + 1);\n        let DD = kitx_1.default.pad2(date.getUTCDate());\n        let HH = kitx_1.default.pad2(date.getUTCHours());\n        let mm = kitx_1.default.pad2(date.getUTCMinutes());\n        let ss = kitx_1.default.pad2(date.getUTCSeconds());\n        return `${YYYY}-${MM}-${DD}T${HH}:${mm}:${ss}Z`;\n    }\n    /**\n     * Parse filter into a object which's type is map[string]string\n     * @param filter query param\n     * @return the object\n     */\n    static query(filter) {\n        if (!filter) {\n            return {};\n        }\n        let ret = {};\n        flatMap(ret, filter);\n        return ret;\n    }\n    /**\n     * Get signature according to signedParams, method and secret\n     * @param signedParams params which need to be signed\n     * @param method http method e.g. GET\n     * @param secret AccessKeySecret\n     * @return the signature\n     */\n    static getRPCSignature(signedParams, method, secret) {\n        var normalized = normalize(signedParams);\n        var canonicalized = canonicalize(normalized);\n        var stringToSign = `${method}&${encode('/')}&${encode(canonicalized)}`;\n        const key = secret + '&';\n        return kitx_1.default.sha1(stringToSign, key, 'base64');\n    }\n    /**\n     * Parse array into a string with specified style\n     * @param array the array\n     * @param prefix the prefix string\n     * @style specified style e.g. repeatList\n     * @return the string\n     */\n    static arrayToStringWithSpecifiedStyle(array, prefix, style) {\n        if (!array) {\n            return '';\n        }\n        if (style === 'repeatList') {\n            let target = {};\n            replaceRepeatList(target, array, prefix);\n            return querystring_1.default.stringify(target, '&&');\n        }\n        else if (style === 'json') {\n            return JSON.stringify(toMap(array));\n        }\n        else if (style === 'simple') {\n            return array.join(',');\n        }\n        else if (style === 'spaceDelimited') {\n            return array.join(' ');\n        }\n        else if (style === 'pipeDelimited') {\n            return array.join('|');\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Transform input as map.\n     */\n    static parseToMap(input) {\n        return toMap(input);\n    }\n    static getEndpoint(endpoint, serverUse, endpointType) {\n        if (endpointType == \"internal\") {\n            let strs = endpoint.split(\".\");\n            strs[0] += \"-internal\";\n            endpoint = strs.join(\".\");\n        }\n        if (serverUse && endpointType == \"accelerate\") {\n            return \"oss-accelerate.aliyuncs.com\";\n        }\n        return endpoint;\n    }\n    /**\n    * Encode raw with base16\n    * @param raw encoding data\n    * @return encoded string\n    */\n    static hexEncode(raw) {\n        return raw.toString(\"hex\");\n    }\n    /**\n     * Hash the raw data with signatureAlgorithm\n     * @param raw hashing data\n     * @param signatureAlgorithm the autograph method\n     * @return hashed bytes\n    */\n    static hash(raw, signatureAlgorithm) {\n        if (signatureAlgorithm === \"ACS3-HMAC-SHA256\" || signatureAlgorithm === \"ACS3-RSA-SHA256\") {\n            const obj = crypto_1.default.createHash('sha256');\n            obj.update(raw);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm == \"ACS3-HMAC-SM3\") {\n            const obj = crypto_1.default.createHash('sm3');\n            obj.update(raw);\n            return obj.digest();\n        }\n    }\n    static signatureMethod(secret, source, signatureAlgorithm) {\n        if (signatureAlgorithm === \"ACS3-HMAC-SHA256\") {\n            const obj = crypto_1.default.createHmac('sha256', secret);\n            obj.update(source);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm === \"ACS3-HMAC-SM3\") {\n            const obj = crypto_1.default.createHmac('sm3', secret);\n            obj.update(source);\n            return obj.digest();\n        }\n        else if (signatureAlgorithm === \"ACS3-RSA-SHA256\") {\n            if (!secret.startsWith(PEM_BEGIN)) {\n                secret = PEM_BEGIN + secret;\n            }\n            if (!secret.endsWith(PEM_END)) {\n                secret = secret + PEM_END;\n            }\n            var signerObject = crypto_1.default.createSign(\"RSA-SHA256\");\n            signerObject.update(source);\n            var signature = signerObject.sign({ key: secret, padding: crypto_1.default.constants.RSA_PKCS1_PADDING });\n            return signature;\n        }\n    }\n    /**\n     * Get the authorization\n     * @param request request params\n     * @param signatureAlgorithm the autograph method\n     * @param payload the hashed request\n     * @param acesskey the acesskey string\n     * @param accessKeySecret the accessKeySecret string\n     * @return authorization string\n     */\n    static getAuthorization(request, signatureAlgorithm, payload, acesskey, accessKeySecret) {\n        const canonicalURI = (request.pathname || \"\").replace(\"+\", \"%20\").replace(\"*\", \"%2A\").replace(\"%7E\", \"~\");\n        const method = request.method;\n        const canonicalQueryString = getAuthorizationQueryString(request.query);\n        const tuple = getAuthorizationHeaders(request.headers);\n        const canonicalheaders = tuple[\"canonicalheaders\"];\n        const signedHeaders = tuple[\"hsKeys\"];\n        const canonicalRequest = method + \"\\n\" + canonicalURI + \"\\n\" + canonicalQueryString + \"\\n\" + canonicalheaders + \"\\n\" +\n            signedHeaders.join(\";\") + \"\\n\" + payload;\n        let raw = Buffer.from(canonicalRequest);\n        const stringToSign = signatureAlgorithm + \"\\n\" + Client.hexEncode(Client.hash(raw, signatureAlgorithm));\n        const signature = Client.hexEncode(Client.signatureMethod(accessKeySecret, stringToSign, signatureAlgorithm));\n        const auth = `${signatureAlgorithm} Credential=${acesskey},SignedHeaders=${signedHeaders.join(';')},Signature=${signature}`;\n        return auth;\n    }\n    static getEncodePath(path) {\n        if (typeof path === 'undefined' || path === null) {\n            return '';\n        }\n        let strs = path.split('/');\n        for (let i = 0; i < strs.length; i++) {\n            strs[i] = encode(strs[i]);\n        }\n        return strs.join('/');\n    }\n    static getEncodeParam(param) {\n        if (typeof param === 'undefined' || param === null) {\n            return '';\n        }\n        return encode(param);\n    }\n}\nexports.default = Client;\n//# sourceMappingURL=client.js.map"]}